[["index.html", "高级计量暑期研讨 前言", " 高级计量暑期研讨 胡华平 2022-06-29 前言 你好，世界(Hello World！)。 欢迎所有能看到这里的朋友们！ 欢迎参加2022年西北农林科技大学经济管理学院高级计量经济学暑期培训班！ 大约花费两天时间，我将讲授非参数估计方法和RDD方法两个内容模块。 这里给大家的是相关配套案例和R代码分析！ 感谢开源编程世界！ 希望R语言开源统计社区因为你们的关注和加入而更加活跃和充满生命力！ "],["lab-R-beginner.html", "Lab 1 R语言在计量经济的应用（新手启蒙） 1.1 现代开源统计软件的趋势特点 1.2 R在论文写作和项目协作中的应用 1.3 R及Rstudio简介 1.4 一些R学习资源 1.5 关于计量经济学习的几点建议 1.6 关于编程语言的几点建议 参考文献", " Lab 1 R语言在计量经济的应用（新手启蒙） 在这个部分，我将就如下一些话题做一些介绍，并会进行现场操作展示。 1.1 现代开源统计软件的趋势特点 1.1.1 封闭VS开源 1.1.2 文学化编程 1.2 R在论文写作和项目协作中的应用 参看我的在线书稿：R漂流记，尤其是第8章学术助手。 1.2.1 科技论文写作演示（现场操作） 1.2.2 科研项目写作演示（现场操作） 1.3 R及Rstudio简介 1.3.1 Rstudio基本视窗 安装R软件和第三方编译软件Rstudio （开源软件，免费公开，自行安装） R CRAN主站下载安装R程序(根据自己的电脑操作系统选择)。网址https://cran.r-project.org/ Rstudio主站下载安装Rstudio软件。网址https://www.rstudio.com/ 1.3.2 项目文件结构 1.3.3 R包（R packages） 1.3.4 R编程风格：Classic R VS tidyvese R 1.4 一些R学习资源 R语言及Rmarkdown语言快速上手参考资料 。 说明： 本文档中提到的图书pdf文件可以通过百度云下载（下载地址：https://pan.baidu.com/s/1ZRuVSf2Jv_u3C_XmAUingA）。 下载地址永久有效！如有问题请反馈wsad2008@gmail.com。 材料仅供学习交流使用，请尊重原作者的版权！祝大家开心学习，学有所成！ 1.4.1 用R进行编程统计分析 Adler, J. R in a Nutshell (2ed) [M], Reilly, 2012.这是R语言学习的红宝书之一，手中常备，随时翻阅。建议要通览一遍，并对照实例运行代码。 Crawley, M. J. The R Book (2nd) [M], Wiley, 2013. 这是R语言学习的红宝书之二。两本红宝书写作风格不同，自己挑一本就行。 Wickham, H. and G. Grolemund. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data [M], O’Reilly Media, 2017. 这是Hadley大神的一大力作。这是进入R语言统计功力快速升级的超级秘笈！它让你能很快找到指哪打哪的酣畅淋漓！你会因为它更加热爱R！建议在红宝书之后务必要好好学习这本秘籍！ Hadley, W. Advanced R [M], CRC Press, 2015.（高级进阶学习，更深入地认识R语言的基本奥义。建议后续学习。简单说，要成为R高手，就应该参透R语言的内部逻辑和底层架构！） 1.4.2 用R进行绘图（图形可视化） Hadley, W. ggplot2: Elegant Graphics for Data Analysis [M], Springer, 2016. 没错，这又是Hadley大神出品。R可视化绘图ggplot2的创造者。说实话，他的文笔简练精准，毫不拖泥带水。真的把ggplot2绘图思想说得一清二楚！让你的R可视化技能瞬间提升N级。 1.4.3 用R来写文章 Rmarkdown语言与谢益辉大神： 关注一个bookdown网站https://bookdown.org/。里面都是用Rmarkdown写的书，免费下载，书籍内容作者还会不断更新！改变了出版行业！下面几本书都可以在线阅读和下载！！（神奇吧！） Xie, Y. Dynamic Documents with R and knitr [M], Chapman &amp; Hall/CRC, 2015. 谢大神的一本书，基本让你明白为什么可以抛弃word、ppt…… Xie, Y. bookdown: Authoring Books and Technical Documents with R Markdown [M], Chapman &amp; Hall _ CRC 2016. 谢大神的又一本书，他开发的bookdown包，让你真正的可以抛弃word、ppt…… yihui, X. R Markdown: The Definitive Guide [M]2018. 谢大神的新作，你可以完全掌握Rmarkdown了。 1.4.4 project版本控制和团队协作 版本控制系统：git知识学习 什么是“版本控制”？我为什么要关心它呢？ 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 我们对保存着软件源代码的文件作版本控制，但实际上，你可以对任何类型的文件进行版本控制。 代码托管和协作：github网站 注册github账号（请用你们西农邮箱注册，高校邮箱github有惊喜）。 安装github桌面软件（如果熟练掌握了git命令操作，这一步骤可以跳过）。 后github就是我们的交流平台了——你们可以管理文件、托管R代码和版本控制,并进行协作。 1.5 关于计量经济学习的几点建议 可以参看我博文中的几点拙论：“计量经济学的那点调性和套路”（点击访问博文） 1.6 关于编程语言的几点建议 人在江湖走，该有的技能还得练到手！ 技术手段是不断发展变化的，要有拥抱未来的情怀！R或Rmarkdown也只是选择之一，不是唯一。够你用和适合你就行！ 坚持并常用，才是熟练掌握一门语言的根本所在！R和Rmarkdown，就跟你学英语一样。相信我，半年不学不用，你的英语也就忘得差不多了！ 不要看翻译成中文的图书或“教程”！编程语言都是英语的世界！你坚持用英语，顶住了最开始的吃力、费解和艰难，后面必然就是你得胜凯旋的荣光时刻！ 参考文献 "],["lab-mean-est.html", "Lab 2 均值估计（模拟数据） 2.1 实验说明 2.2 数据集描述 2.3 均值估计 2.4 整合计算结果 2.5 绘制分析图 2.6 展示分析结果 参考文献", " Lab 2 均值估计（模拟数据） 2.1 实验说明 2.1.1 实验内容 实验目标：非参数均值估计，复现Figure 19.1a计算过程及结果。（参看：HANSEN B. Econometrics[M].2021（作者手稿）. 第19章 Nonparametric Regression. ） 主要内容包括： 箱组均值估计 滚动均值估计 核函数均值估计 2.1.2 材料准备 软件环境：编译器为Rstudio（要求R 4.1及以上版本） R代码文件：工作项目（R project）根目录下的Rscript/hensen21-fig19-1a.R文件夹 # don&#39;t run here ! # only show you the code file path! source(here(&quot;Rscript/hensen21-fig19-1a.R&quot;), encoding = &quot;UTF-8&quot;) 2.2 数据集描述 为了更好地进行数据验证，我们将根据如下规则生成蒙特卡洛模拟数据集： \\[\\begin{align} Y_i &amp;= m(X) +e_i =\\frac{sin(\\frac{\\pi}{4}\\cdot(X_i-2))}{\\frac{\\pi}{4}\\cdot(X_i-2)} +e_i\\\\ X_i &amp;\\sim U(0,10)\\\\ e_i &amp;\\sim N(0, 2)\\\\ n &amp;=100 \\end{align}\\] 此时，我们具有上帝视角，实际上已经知道数据生成机制（DGP） 此时，我们心里面已知真实模型为非线性的 n &lt;- 100 xm &lt;- 10 set.seed(180) # for reproducible xdat &lt;- runif(n,0,xm) a &lt;- pi/4 m &lt;- sin((xdat-2)*a)/((xdat-2)*a) ydat &lt;- m + rnorm(n)/4 dt &lt;- tibble(index = 1:length(xdat), X = xdat, Y = ydat) 2.2.1 数据呈现 dt %&gt;% #add_column(obs = 1:nrow(.), .before = &quot;X&quot;) %&gt;% DT::datatable( caption = paste0(&quot;模拟的样本数据集(n=&quot;,n,&quot;)&quot;), options = list(dom = &quot;tip&quot;, pageLength =8))%&gt;% formatRound(c(2:3), digits = 4) 样本数据的描述性统计如下： summary(dt) index X Y Min. : 1 Min. :0.1 Min. :-0.65 1st Qu.: 26 1st Qu.:2.3 1st Qu.:-0.06 Median : 50 Median :4.6 Median : 0.27 Mean : 50 Mean :4.9 Mean : 0.38 3rd Qu.: 75 3rd Qu.:7.5 3rd Qu.: 0.81 Max. :100 Max. :9.9 Max. : 1.46 2.2.2 数据散点图 # basic scatter plot p0 &lt;- ggplot() + geom_point(aes(X, Y),data = dt, pch=21) + labs(x= &quot;自变量X&quot;, y =&quot;因变量Y&quot;) + scale_x_continuous(breaks = seq(0,10,1), limits = c(0,10)) + scale_y_continuous(breaks = seq(-1,2,0.5), limits = c(-1,2)) + theme_bw() # show the scatter p0 图 2.1: 样本数据散点图n=100 2.3 均值估计 对于箱组均值均值估计：箱组数为n=5 \\[\\begin{align} \\hat{m}(x)=\\frac{\\sum_{i=1}^{n} \\mathbb{1}\\left\\{\\left|X_{i}-x\\right| \\leq h\\right\\} \\cdot Y_{i}}{\\sum_{i=1}^{n} \\mathbb{1}\\left\\{\\left|X_{i}-x\\right| \\leq h\\right\\}} \\end{align}\\] 对于滚动箱组均值估计：箱组数为n=1001 \\[\\begin{align} \\hat{m}(x)=\\frac{\\sum_{i=1}^{n} \\mathbb{1}\\left\\{\\left|X_{i}-x\\right| \\leq h\\right\\} \\cdot Y_{i}}{\\sum_{i=1}^{n} \\mathbb{1}\\left\\{\\left|X_{i}-x\\right| \\leq h\\right\\}} \\end{align}\\] 对于核均值估计：箱组数为n=1001 \\[\\begin{align} \\hat{m}_{\\mathrm{nw}}(x)=\\frac{\\sum_{i=1}^{n} K\\left(\\frac{X_{i}-x}{h}\\right) Y_{i}}{\\sum_{i=1}^{n} K\\left(\\frac{X_{i}-x}{h}\\right)} \\end{align}\\] 三者的具体代码计算如下： #### calculate #### h1 &lt;- 1 # for binned h2 &lt;- h1/sqrt(3) # for NW x0 &lt;- seq(1,9,2) # bins break x0n &lt;- length(x0) # index of Logic value in each bins k0 &lt;- (abs(x0%*%matrix(1,1,n)-matrix(1,x0n,1)%*%t(xdat)) &lt;= h1) # binned means m0 &lt;- (k0%*%ydat)/rowSums(k0) # create new x with n=1001 x &lt;- seq(0,xm,.01) xn &lt;- length(x) # 1001 # for Rolling, dim(k1)=c(1001, 100) k1 &lt;- (abs(x%*%matrix(1,1,n)-matrix(1,xn,1)%*%t(xdat)) &lt;= h1) m1 &lt;- (k1%*%ydat)/rowSums(k1) # for NW, dim(k2)=c(1001, 100) k2 &lt;- dnorm(abs(x%*%matrix(1,1,n)-matrix(1,xn,1)%*%t(xdat))/h2) m2 &lt;- (k2%*%ydat)/rowSums(k2) 2.4 整合计算结果 2.4.1 基于箱组数的结果整合（N=1001） 根据前面的计算，我们把三种方法的箱组均值计算过程及结果组合到一张表里来： tbl_result &lt;- tibble(id = 1:length(x), x = x, x_upr = x +0.01) %&gt;% # N=1001 bins # now n=100 bins mutate(bd = cut_interval(x,length = 2, right=FALSE)) %&gt;% mutate( lwr = as.numeric(str_extract(bd, &quot;(\\\\d{1})(?=\\\\,)&quot;)), upr = as.numeric(str_extract(bd, &quot;(?&lt;=\\\\,)(\\\\d{1,2})&quot;)), mid = 0.5*(lwr+ upr) ) %&gt;% # binnd with h1 =2 mutate(lft = x-h1, rgt = x +h1, bins = str_c(&#39;[&#39;,lft,&#39;,&#39;,rgt, &#39;)&#39;)) %&gt;% # add all means estimated mutate(m0 = rep(m0, times=c(200,200,200,200,201)), m1 = as.vector(m1), m2 = as.vector(m2)) 下面展示数据表结果： tbl_result %&gt;% #add_column(obs = 1:nrow(.), .before = &quot;X&quot;) %&gt;% DT::datatable( caption = paste0(&quot;基于箱组数的结果整合（N=1001）&quot;), options = list(dom = &quot;tip&quot;, pageLength =10, scrollX = TRUE)) %&gt;% formatRound(c(2:3), digits = 2) %&gt;% formatRound(c(11:13), digits = 4) 2.4.2 匹配样本数据和箱组（Nn=100100） 考虑到每1个样本数据点，都会被不同的箱组所“套中”，因此我们现在匹配样本数据（n=100）到不同的箱组（N=1001）中去，最终得到了Nn=100100行的计算表。 具体计算代码为： tbl_match &lt;- tbl_result %&gt;% mutate(data = map(x,~dt)) %&gt;% unnest(data) %&gt;% mutate( isbins = ifelse( ((X&gt;=x-h1)&amp; (X&lt;(x+h1))), 1, 0) ) %&gt;% mutate( k0=ifelse( ((X&gt;=lwr)&amp; (X&lt;upr)), 1, 0), k1=as.numeric(as.vector(t(k1))), k2 = as.vector(t(k2)) ) %&gt;% mutate(bd = as.character(bd)) 2.4.3 获得不同方法下的计算表格 现在给出三种方法下的计算表： # binned mean tbl_m0 &lt;- tbl_match %&gt;% filter(k0==1) %&gt;% select(index, X, Y, bd,lwr, upr,mid,k0,m0) %&gt;% unique() %&gt;% arrange(index) %&gt;% group_by(bd) %&gt;% mutate(sum_k = sum(k0), sum_ky = sum(k0*Y)) %&gt;% ungroup() %&gt;% mutate(bins = bd) %&gt;% rename(&quot;x&quot;=&quot;mid&quot;) # scrolling mean tbl_m1 &lt;- tbl_match %&gt;% filter(k1==1) %&gt;% select(index, X, Y, bd,bins,lft, rgt,x,k1,m1) %&gt;% unique() %&gt;% arrange(lft,index) %&gt;% group_by(x) %&gt;% mutate(sum_k = sum(k1), sum_ky = sum(k1*Y)) %&gt;% ungroup() %&gt;% rename(&quot;lwr&quot;=&quot;lft&quot;, &quot;upr&quot;=&quot;rgt&quot;) # NW kernel mean tbl_m2 &lt;- tbl_match %&gt;% #filter(k1==1) %&gt;% select(index, X, Y, bd,bins,lft, rgt,x,k2,m2) %&gt;% unique() %&gt;% arrange(lft,index) %&gt;% group_by(x) %&gt;% mutate(sum_k = sum(k2), sum_ky = sum(k2*Y)) %&gt;% ungroup() %&gt;% rename(&quot;lwr&quot;=&quot;lft&quot;, &quot;upr&quot;=&quot;rgt&quot;) 例如，我们这里展示滚动箱组均值估计的计算表： 2.4.4 生成箱组区隔及相关计算表 # help function gen_bins &lt;- function(df){ out &lt;- df %&gt;% select(#index, X, Y, x, bins,sum_ky, sum_k, starts_with(&quot;m&quot;)) %&gt;% unique() %&gt;% arrange(x) %&gt;% mutate(x=number(x, 0.01)) } bin1 &lt;- gen_bins(tbl_m0) n1 &lt;- nrow(bin1) bin2 &lt;- gen_bins(tbl_m1) n2 &lt;- nrow(bin2) bin3 &lt;- gen_bins(tbl_m2) n3 &lt;- nrow(bin3) 2.5 绘制分析图 2.5.1 绘制底图 #### draw plot #### # basic scatter plot fsize &lt;- 16 p0 &lt;- ggplot() + geom_point(aes(X, Y),data = dt, pch=21) + labs(x= &quot;自变量X&quot;, y =&quot;因变量Y&quot;) + scale_x_continuous(breaks = seq(0,10,1), limits = c(0,10)) + scale_y_continuous(breaks = seq(-1,2,0.5), limits = c(-1,2)) + theme_bw() + theme(text = element_text(size = 16)) ### basic with bins p00 &lt;- p0 + geom_vline(xintercept = x0, lty=&quot;dashed&quot;) + geom_point(aes(X, Y, color=as.factor(bd)), data = tbl_m0, pch=21) + geom_rect(aes(ymin=-1,ymax=2, xmin= lwr, xmax = upr, fill = as.factor(bd)), data = tbl_m0 %&gt;% select(bd, lwr, upr) %&gt;% unique, alpha = 0.05, inherit.aes = FALSE) + theme(legend.position = &quot;none&quot;, text = element_text(size = 16)) ### basic with means p000 &lt;- p00 + geom_point(aes(x, m0), data = tbl_m0 %&gt;% select(x, m0) %&gt;% unique(), pch=15, color=&quot;black&quot;, size=3) 2.5.2 箱组均值估计图形 ### binned plot p1 &lt;- p00 + geom_point(aes(x, m0), data = tbl_m0 %&gt;% select(x, m0) %&gt;% unique(), pch=15, color=&quot;black&quot;, size=3) + geom_segment(aes(x =lwr, xend=upr, y =m0, yend = m0, color=as.factor(bd)), data = tbl_m0 %&gt;% select(lwr,bd,upr, m0) %&gt;% unique(), lty=&quot;solid&quot;, lwd=0.8) + theme(legend.position = &quot;none&quot;, text = element_text(size = fsize)) 2.5.3 滚动箱组均值估计图形 ## scrolling plot p20 &lt;- p0 + geom_point(aes(x, m1, color=as.factor(bd)), data = tbl_m1 %&gt;% select(x,m1,bins,bd) %&gt;% unique(), pch=20) + theme(legend.position = &quot;none&quot;, text = element_text(size = fsize)) p2 &lt;- p0 + geom_point(aes(x, m0), data = tbl_m0 %&gt;% select(x, m0) %&gt;% unique(), pch=15, color=&quot;black&quot;) + geom_line(aes(x, m1, color=as.factor(bd)), data = tbl_m1 %&gt;% select(x,m1,bins,bd) %&gt;% unique(), lty=&quot;solid&quot;, lwd=0.8) + theme(legend.position = &quot;none&quot;, text = element_text(size = fsize)) 2.5.4 NW核均值估计图形 ## Nadaraya-Watson plot p3 &lt;- p0 + geom_point(aes(x, m0), data = tbl_m0 %&gt;% select(x, m0) %&gt;% unique(), pch=15, color=&quot;black&quot;) + geom_line(aes(x, m2, color=as.factor(bd)), data = tbl_m2 %&gt;% select(x,m2,bins,bd) %&gt;% unique(), lty=&quot;solid&quot;, lwd=0.8) + theme(legend.position = &quot;none&quot;, text = element_text(size = fsize)) 2.5.5 三种方法的图形 ## all three plot p_all &lt;- p0 + geom_vline(xintercept = x0, lty=&quot;dashed&quot;) + geom_point(aes(x, m0), data = tbl_m0 %&gt;% select(x, m0) %&gt;% unique(), pch=15, size =3, color=&quot;black&quot;) + geom_segment(aes(x =lwr, xend=upr, y =m0, yend = m0, color= &quot;binned&quot;), data = tbl_m0 %&gt;% select(lwr,bd,upr, m0) %&gt;% unique(), lty=&quot;solid&quot;, lwd=0.8) + geom_line(aes(x, m1, color=&quot;rolling&quot;), data = tbl_m1 %&gt;% select(x,m1) %&gt;% unique(), lty=&quot;solid&quot;, lwd=0.8) + geom_line(aes(x, m2, color = &quot;NW&quot;), data = tbl_m2 %&gt;% select(x,m2) %&gt;% unique(), lty=&quot;solid&quot;, lwd=0.8) + scale_color_manual( name=&quot;mx&quot;, breaks = c(&quot;binned&quot;, &quot;rolling&quot;,&quot;NW&quot;), values=c(&quot;green&quot;, &quot;red&quot;,&quot;blue&quot;))+ theme(legend.position = &quot;right&quot;, text = element_text(size = fsize)) 2.6 展示分析结果 2.6.1 箱组均值估计结果 利用箱组均值估计公式，我们可以计算得到不同箱组的均值估计： bin1 %&gt;% #select(x, bins, sum_KY, sum_K, mx) %&gt;% DT::datatable(options = list(dom = &quot;t&quot;))%&gt;% formatRound(c(1,3,5),c(0,4,4)) 箱组内因变量观测值的求和sum_ky \\(=\\sum_{i=1}^{n} \\mathbb{1}\\left\\{\\left|X_{i}-x\\right| \\leq h\\right\\} \\cdot Y_{i}\\) 箱组的样本数sum_k \\(=\\sum_{i=1}^{n} \\mathbb{1}\\left\\{\\left|X_{i}-x\\right| \\leq h\\right\\}\\) 箱组的均值估计m0 \\(=\\widehat{m}(x_j),j \\in (1,2,\\cdots,5)\\) 首先我们展示的是5个箱组的划分： p00 说明：a)垂直虚线表示箱组中心取值点 \\(x_j\\)；b)不同矩形颜色区块表示不同箱组。 根据箱组均值计算值，我们展示在散点图中： p000 简单地，可将箱组均值作为对这一箱组条件期望函数CEF的近似： p1 2.6.2 滚动箱组均值估计结果 利用箱组均值估计公式，我们可以计算得到不同箱组的均值估计： bin2 %&gt;% DT::datatable( options = list(dom = &quot;tip&quot;, pageLength =5)) %&gt;% formatRound(c(3,5),c(4,4)) 箱组内因变量观测值的求和sum_ky \\(=\\sum_{i=1}^{n} \\mathbb{1}\\left\\{\\left|X_{i}-x\\right| \\leq h\\right\\} \\cdot Y_{i}\\) 箱组的样本数sum_k \\(=\\sum_{i=1}^{n} \\mathbb{1}\\left\\{\\left|X_{i}-x\\right| \\leq h\\right\\}\\) 箱组的均值估计m1 \\(=\\widehat{m}(x_j),j \\in (1,2,\\cdots,1001)\\) 根据箱组均值计算值，我们展示在散点图中： p20 同样地，可将箱组均值作为对这一箱组条件期望函数CEF的近似： p2 2.6.3 NW核均值估计结果 利用箱组均值核函数估计公式，我们可以计算得到不同箱组的均值估计： bin3 %&gt;% DT::datatable( options = list(dom = &quot;tip&quot;, pageLength =5)) %&gt;% formatRound(c(3:5),c(4)) 同样地，可将箱组均值作为对这一箱组条件期望函数CEF的近似： p3 2.6.4 三种方法估计对比 p_all NW核估计方法相比箱组均值估计和滚动箱组均值估计要更加平滑。 参考文献 "],["lab-local-reg.html", "Lab 3 局部回归（模拟数据） 3.1 实验说明 3.2 数据集描述 3.3 局部回归估计过程 3.4 整合计算结果 3.5 绘制分析图 3.6 展示分析结果 参考文献", " Lab 3 局部回归（模拟数据） 3.1 实验说明 3.1.1 实验内容 实验目标：非参数局部均值回归，复现Figure 19.1b过程及结果（参看：HANSEN B. Econometrics[M].2021（作者手稿）. 第19章 Nonparametric Regression. ） 主要内容包括： 箱组回归估计 滚动回归估计 局部线性回归估计 3.1.2 材料准备 软件环境：编译器为Rstudio（要求R 4.1及以上版本） R代码文件：工作项目（R project）根目录下的Rscript/hensen21-fig19-1b.R文件夹 # don&#39;t run here ! # only show you the code file path! source(here(&quot;Rscript/hensen21-fig19-1b.R&quot;), encoding = &quot;UTF-8&quot;) 3.2 数据集描述 为了更好地进行数据验证，我们继续使用前面蒙特卡洛模拟数据集： \\[\\begin{align} Y_i &amp;= m(X) +e_i =\\frac{sin(\\frac{\\pi}{4}\\cdot(X_i-2))}{\\frac{\\pi}{4}\\cdot(X_i-2)} +e_i\\\\ X_i &amp;\\sim U(0,10)\\\\ e_i &amp;\\sim N(0, 2)\\\\ n &amp;=100 \\end{align}\\] 此时，我们具有上帝视角，实际上已经知道数据生成机制（DGP） 此时，我们心里面已知真实模型为非线性的 # simulation data set n &lt;- 100 xm = 10 x &lt;- seq(0,xm,.01) xn &lt;- length(x) set.seed(180) xdat &lt;- runif(n,0,xm) a &lt;- pi/4 m &lt;- sin(xdat*a)/(xdat*a) m &lt;- sin((xdat-2)*a)/((xdat-2)*a) ydat &lt;- m + rnorm(n)/4 dt &lt;- tibble(index = 1:length(xdat), X = xdat, Y = ydat) 3.2.1 数据呈现 dt %&gt;% #add_column(obs = 1:nrow(.), .before = &quot;X&quot;) %&gt;% DT::datatable( caption = paste0(&quot;模拟的样本数据集(n=&quot;,n,&quot;)&quot;), options = list(dom = &quot;tip&quot;, pageLength =8))%&gt;% formatRound(c(2:3), digits = 4) 样本数据的描述性统计如下： summary(dt) index X Y Min. : 1 Min. :0.1 Min. :-0.65 1st Qu.: 26 1st Qu.:2.3 1st Qu.:-0.06 Median : 50 Median :4.6 Median : 0.27 Mean : 50 Mean :4.9 Mean : 0.38 3rd Qu.: 75 3rd Qu.:7.5 3rd Qu.: 0.81 Max. :100 Max. :9.9 Max. : 1.46 3.2.2 数据散点图 # basic scatter plot p0 &lt;- ggplot() + geom_point(aes(X, Y),data = dt, pch=21) + labs(x= &quot;自变量X&quot;, y =&quot;因变量Y&quot;) + scale_x_continuous(breaks = seq(0,10,1), limits = c(0,10)) + scale_y_continuous(breaks = seq(-1,2,0.5), limits = c(-1,2)) + theme_bw() # show the scatter p0 图 3.1: 样本数据散点图n=100 3.3 局部回归估计过程 3.3.1 基本原理 对于箱组局部回归估计：箱组数为n=5 \\[\\widehat{m}(x)={\\widehat{Y}_i} \\quad \\text{(OLS)}\\] 注意：此处OLS回归的目标是得到不同箱组的预测值（Nn=1001）个，因此我们需要先根据样本数据（n=100）得到拟合线的截距和斜率，再进行新箱组数据（Nn=1001）进行预测。 对于滚动箱组局部回归估计，箱组数为n=1001，我们使用矩形核函数，采用局部加权OLS方法计算不同箱组下仅含截距项的回归模型的截距系数\\(Y=m(X)+e \\simeq m(x)+e\\)： \\[\\begin{align} \\widehat{m}_{\\mathrm{nw}}(x)=\\underset{m}{\\operatorname{argmin}} \\sum_{i=1}^{n} K\\left(\\frac{X_{i}-x}{h}\\right)\\left(Y_{i}-m\\right)^{2} \\end{align}\\] 对于核函数局部回归估计，箱组数为n=1001，我们使用高斯核函数，采用局部OLS方法计算得到下式的\\(\\beta_0 =m(x)\\) \\[\\begin{align} Y &amp;= m(X) +e \\\\ &amp;\\simeq m(x) + m^{\\prime}(x)(X-x) +e \\\\ &amp; = \\beta_0 + \\beta_1\\cdot(X-x) +e \\end{align}\\] 以上模型可以视作为一元线性回归模型，其中 \\(\\beta_0 =m(x);\\beta_1=m^{\\prime}(x)\\)。 3.3.2 局部回归计算 3.3.2.1 对于局部滚动回归和局部线性回归 局部滚动回归和局部线性回归，二者本质上是一样的，只是使用的核函数不同，二者具体代码计算如下： #### calculate #### # set bandwidth h1 &lt;- 1 h2 &lt;- h1/sqrt(3) # Rolling LL and Kernel LL estimation mg &lt;- matrix(0,xn,1) mr &lt;- matrix(0,xn,1) for (j in 1:xn){ xj &lt;- xdat-x[j] z &lt;- cbind(matrix(1,n,1),xj) k1 &lt;- abs(xj) &lt; h1 # Rectangle Kernel k2 &lt;- dnorm(xj/h2) # Gaussian Kernel zk1 &lt;- z*k1 zk2 &lt;- z*k2 betar &lt;- solve(t(zk1)%*%z,t(zk1)%*%ydat) betag &lt;- solve(t(zk2)%*%z,t(zk2)%*%ydat) mr[j] &lt;- betar[1] # for Rolling LL mg[j] &lt;- betag[1] # for Kernel LL } 3.3.2.2 对于局部箱组回归 如前所属，局部箱组回归总体来说需要进行两步运算： 我们需要先根据样本数据（n=100）直接使用OLS方法得到箱组内拟合线的截距和斜率，再进行新箱组数据（Nn=1001）进行预测。 局部箱组回归的具体代码计算如下： # Binned LL estimation x0 &lt;- c(1,3,5,7,9) ## for bins 1 x1 &lt;- as.matrix(subset(xdat,xdat&lt;2)) y1 &lt;- as.matrix(subset(ydat,xdat&lt;2)) z1 &lt;- cbind(matrix(1,length(y1),1),x1) beta1 &lt;- solve(t(z1)%*%z1,t(z1)%*%y1) # get OLS coefficients m1 &lt;- beta1[1]+beta1[2]*x0[1] # mean centers x1 &lt;- as.matrix(subset(x,x&lt;2)) f1 &lt;- beta1[1]+x1*beta1[2] # forecast with new data ## for bins 2 x2 &lt;- as.matrix(subset(xdat,(xdat&gt;=2)&amp;(xdat&lt;4))) y2 &lt;- as.matrix(subset(ydat,(xdat&gt;=2)&amp;(xdat&lt;4))) z2 &lt;- cbind(matrix(1,length(y2),1),x2) beta2 &lt;- solve(t(z2)%*%z2,t(z2)%*%y2) m2 &lt;- beta2[1]+beta2[2]*x0[2] x2 &lt;- as.matrix(subset(x,(x&gt;=2)&amp;(x&lt;4))) f2 &lt;- beta2[1]+x2*beta2[2] ## for bins 3 x3 &lt;- as.matrix(subset(xdat,(xdat&gt;=4)&amp;(xdat&lt;6))) y3 &lt;- as.matrix(subset(ydat,(xdat&gt;=4)&amp;(xdat&lt;6))) z3 &lt;- cbind(matrix(1,length(y3),1),x3) beta3 &lt;- solve(t(z3)%*%z3,t(z3)%*%y3) m3 &lt;- beta3[1]+beta3[2]*x0[3] x3 &lt;- as.matrix(subset(x,(x&gt;=4)&amp;(x&lt;6))) f3 &lt;- beta3[1]+x3*beta3[2] ## for bins 4 x4 &lt;- as.matrix(subset(xdat,(xdat&gt;=6)&amp;(xdat&lt;8))) y4 &lt;- as.matrix(subset(ydat,(xdat&gt;=6)&amp;(xdat&lt;8))) z4 &lt;- cbind(matrix(1,length(y4),1),x4) beta4 &lt;- solve(t(z4)%*%z4,t(z4)%*%y4) m4 &lt;- beta4[1]+beta4[2]*x0[4] x4 &lt;- as.matrix(subset(x,(x&gt;=6)&amp;(x&lt;8))) f4 &lt;- beta4[1]+x4*beta4[2] ## for bins 5 x5 &lt;- as.matrix(subset(xdat,xdat&gt;=8)) y5 &lt;- as.matrix(subset(ydat,xdat&gt;=8)) z5 &lt;- cbind(matrix(1,length(y5),1),x5) beta5 &lt;- solve(t(z5)%*%z5,t(z5)%*%y5) m5 &lt;- beta5[1]+beta5[2]*x0[5] x5 &lt;- as.matrix(subset(x,(x&gt;=8))) f5 &lt;- beta5[1]+x5*beta5[2] ## combine as data.frame tbl_a0 &lt;- cbind(beta1, beta2,beta3, beta4,beta5) %&gt;% as_tibble(.name_repair = &quot;unique&quot;) %&gt;% rename_all(~paste0(&quot;bd&quot;,1:5)) %&gt;% add_column(par= c(&quot;intercept&quot;, &quot;slope&quot;), .before = &quot;bd1&quot;) ## binned LL CEF estimation m0 &lt;- c(m1,m2,m3,m4,m5) ## mean centers f0 &lt;- c(f1, f2,f3, f4, f5) ## LL estimation 3.4 整合计算结果 3.4.1 基于箱组数的结果整合（N=1001） 根据前面的计算，我们把三种方法的局部回归计算过程及结果组合到一张表里来： #### combine all result #### tbl_result &lt;- tibble(id = 1:length(x), x = x, x_upr = x +0.01) %&gt;% mutate(bd = cut_interval(x,length = 2, right=FALSE)) %&gt;% mutate( lwr = as.numeric(str_extract(bd, &quot;(\\\\d{1})(?=\\\\,)&quot;)), upr = as.numeric(str_extract(bd, &quot;(?&lt;=\\\\,)(\\\\d{1,2})&quot;)), mid = 0.5*(lwr+ upr) ) %&gt;% mutate(lft = x-h1, rgt = x +h1, bins = str_c(&#39;[&#39;,number(lft,0.01),&#39;,&#39;, number(rgt,0.01), &#39;)&#39;)) %&gt;% mutate(my = rep(m0, times=c(200,200,200,200,201)), m0 = (as.vector(f0)), # pay attention here !!! m1 = (as.vector(mr)), m2 = as.vector(mg)) 下面展示数据表结果： tbl_result %&gt;% #add_column(obs = 1:nrow(.), .before = &quot;X&quot;) %&gt;% DT::datatable( caption = paste0(&quot;基于箱组数的结果整合（N=1001）&quot;), options = list(dom = &quot;tip&quot;, pageLength =10, scrollX = TRUE)) %&gt;% formatRound(c(2:3), digits = 2) %&gt;% formatRound(c(11:14), digits = 4) 3.4.2 匹配样本数据和箱组（Nn=100100） 考虑到每1个样本数据点，都会被不同的箱组所“套中”，因此我们现在匹配样本数据（n=100）到不同的箱组（N=1001）中去，最终得到了Nn=100100行的计算表。 具体计算代码为： tbl_match &lt;- tbl_result %&gt;% mutate(data = map(x,~dt)) %&gt;% unnest(data) %&gt;% mutate( isbins = ifelse( ((X&gt;=x-h1)&amp; (X&lt;(x+h1))), 1, 0) ) %&gt;% mutate(bd = as.character(bd)) %&gt;% mutate( isbd = ifelse( ((X&gt;=lwr)&amp; (X&lt;(upr))), 1, 0) ) 3.4.3 获得不同方法下的计算表格 现在给出三种方法下的计算表： # binned LL tbl_m0 &lt;- tbl_match %&gt;% filter(isbins==1) %&gt;% select(index, X, Y, bd,bins,lwr, upr,mid, x,my,m0, isbins) %&gt;% unique() %&gt;% arrange(lwr,index) %&gt;% group_by(x) %&gt;% mutate(sum_k = sum(isbins)) %&gt;% ungroup() # rolling LL tbl_m1 &lt;- tbl_match %&gt;% filter(isbins==1) %&gt;% select(index, X, Y, bd,bins,lft, rgt,x,m1, isbins) %&gt;% unique() %&gt;% arrange(lft,index) %&gt;% group_by(x) %&gt;% mutate(sum_k = sum(isbins)) %&gt;% ungroup() %&gt;% rename(&quot;lwr&quot;=&quot;lft&quot;, &quot;upr&quot;=&quot;rgt&quot;) # kernel LL tbl_m2 &lt;- tbl_match %&gt;% filter(isbins==1) %&gt;% select(index, X, Y, bd,bins,lft, rgt,x,m2, isbins) %&gt;% unique() %&gt;% arrange(lft,index) %&gt;% group_by(x) %&gt;% mutate(sum_k = sum(isbins)) %&gt;% ungroup() %&gt;% rename(&quot;lwr&quot;=&quot;lft&quot;, &quot;upr&quot;=&quot;rgt&quot;) 例如，我们这里展示滚动局部线性非参数估计的计算表： 3.5 绘制分析图 3.5.1 绘制底图 #### draw plot #### # basic plot fsize &lt;- 16 p0 &lt;- ggplot() + geom_point(aes(X, Y),data = dt, pch=21) + labs(x= &quot;自变量X&quot;, y =&quot;因变量Y&quot;) + scale_x_continuous(breaks = seq(0,10,1), limits = c(0,10)) + scale_y_continuous(breaks = seq(-1,2,0.5), limits = c(-1,2)) + theme_bw() + theme(text = element_text(size = fsize)) p00 &lt;- p0 + geom_vline(xintercept = x0, lty=&quot;dashed&quot;) + geom_point(aes(X, Y, color=as.factor(bd)), data = tbl_m0 %&gt;% select(X, Y, bd) %&gt;% unique(), pch=21) + geom_rect(aes(ymin=-1,ymax=2, xmin= lwr, xmax = upr, fill = as.factor(bd)), data = tbl_m0 %&gt;% select(bd, lwr, upr) %&gt;% unique(), alpha = 0.05, inherit.aes = FALSE) + theme(legend.position = &quot;none&quot;, text = element_text(size = fsize)) 3.5.2 箱组回归估计图形 ### binned LL plot p1 &lt;- p00 + geom_point(aes(mid, my), data = tbl_m0 %&gt;% select(mid, my) %&gt;% unique(), pch=15, color=&quot;black&quot;) + geom_line(aes(x =x, y = m0, color=as.factor(bd)), data = tbl_m0 %&gt;% select(x,m0, bd) %&gt;% unique(), lty=&quot;solid&quot;, lwd=0.8) + theme(legend.position = &quot;none&quot;, text = element_text(size = fsize)) 3.5.3 滚动箱组回归估计图形 ## rolling LL plot p2 &lt;- p0 + geom_point(aes(mid, my), data = tbl_m0 %&gt;% select(mid, my) %&gt;% unique(), pch=15, color=&quot;black&quot;) + geom_line(aes(x =x, y = m1, color=as.factor(bd)), data = tbl_m1 %&gt;% select(x,m1, bd) %&gt;% unique(), lty=&quot;solid&quot;, lwd=0.8) + theme(legend.position = &quot;none&quot;, text = element_text(size = fsize)) 3.5.4 局部线性核回归估计图形 ## Kernel LL plot p3 &lt;- p0 + geom_point(aes(mid, my), data = tbl_m0 %&gt;% select(mid, my) %&gt;% unique(), pch=15, color=&quot;black&quot;) + geom_line(aes(x =x, y = m2, color=as.factor(bd)), data = tbl_m2 %&gt;% select(x,m2, bd) %&gt;% unique(), lty=&quot;solid&quot;, lwd=0.8)+ theme(legend.position = &quot;none&quot;, text = element_text(size = fsize)) 3.5.5 三种方法的图形 ## all three plot p_all &lt;- p0 + geom_vline(xintercept = x0, lty=&quot;dashed&quot;) + geom_point(aes(mid, my), data = tbl_m0 %&gt;% select(mid, my) %&gt;% unique(), pch=15, color=&quot;black&quot;, size =2) + geom_line(aes(x =x, y = m0, color=&quot;binned reg&quot;), data = tbl_m0 %&gt;% select(x,m0, bd) %&gt;% unique(), lty=&quot;solid&quot;, lwd=0.8) + geom_line(aes(x, m1, color=&quot;rolling reg&quot;), data = tbl_m1 %&gt;% select(x,m1, bd) %&gt;% unique(), lty=&quot;solid&quot;, lwd=0.8) + geom_line(aes(x, m2, color = &quot;LL reg&quot;), data = tbl_m2 %&gt;% select(x,m2, bd) %&gt;% unique(), lty=&quot;solid&quot;, lwd=0.8) + scale_color_manual( name=&quot;mx reg&quot;, breaks = c(&quot;binned reg&quot;, &quot;rolling reg&quot;,&quot;LL reg&quot;), values=c(&quot;green&quot;, &quot;red&quot;,&quot;blue&quot;))+ theme(legend.position = &quot;right&quot;, text = element_text(size = fsize)) 3.6 展示分析结果 3.6.1 箱组局部回归估计结果 利用箱组局部线性回归估计公式，我们可以计算得到不同箱组的CEF估计： tbl_m0 %&gt;% select(bd, my, bins,x, m0) %&gt;% unique() %&gt;% arrange(x) %&gt;% DT::datatable(options = list(dom = &quot;tip&quot;, pageLength =6))%&gt;% formatRound(c(2,4:5),c(4)) 基于设定的x表示 \\(x_i \\in (0.00, 0.01, 0.02, 0.03, 0.04, 0.05,\\cdots)\\)，共有 \\(N=1001\\)个 箱组回归估计m0 \\(\\widehat{m}(x_i)=\\widehat{Y}_i|x_i\\) 如前，我们设定区隔了5个箱组 p00 根据前面计算表的拟合数据对 \\((x_i,\\widehat{m}(x_i))\\)，我们可以得到箱组线性回归估计结果： p1 3.6.2 滚动箱组局部回归估计结果 我们可以计算得到不同箱组的CEF估计结果： tbl_m1 %&gt;% select(bd, bins,x, m1) %&gt;% unique() %&gt;% arrange(x) %&gt;% DT::datatable(options = list(dom = &quot;tip&quot;, pageLength =6))%&gt;% formatRound(c(3:4),c(4)) 基于设定的x表示 \\(x_i \\in (0.00, 0.01, 0.02, 0.03, 0.04, 0.05,\\cdots)\\)，共有 \\(N=1001\\)个 箱组回归估计m1 \\(=\\widehat{m}(x_i)\\) 根据前面计算表拟合数据对 \\((x_i,\\widehat{m}(x_i))\\)，我们可以得到滚动箱组线性回归估计结果： p2 3.6.3 局部线性回归估计结果 利用局部线性回归估计公式，我们可以计算得到不同箱组的估计： tbl_m2 %&gt;% select(bd, bins,x, m2) %&gt;% unique() %&gt;% arrange(x) %&gt;% DT::datatable(options = list(dom = &quot;tip&quot;, pageLength =6))%&gt;% formatRound(c(3:4),c(4)) 基于设定的x表示 \\(x_i \\in (0.00, 0.01, 0.02, 0.03, 0.04, 0.05,\\cdots)\\)，共有 \\(N=1001\\)个 箱组回归估计m2 \\(=\\widehat{m}(x_i)\\) 根据前面计算表的拟合数据对 \\((x_i,\\widehat{m}(x_i))\\)，我们可以得到局部线性回归估计结果： p3 3.6.4 三种方法估计对比 p_all 尽管三种回归估计方法都较好地估计了真实CEF的趋势，但是局部线性回归LLR拟合方法要更平滑。 参考文献 "],["lab-LL-wage.html", "Lab 4 局部线性估计及效率分析（工资案例） 4.1 实验说明 4.2 案例描述 4.3 过程1：CEF估计的经验参考谱宽选择 4.4 过程2：CEF估计的最优交叉验证谱宽选择 4.5 过程3：基于不同谱宽选择的CEF估计 4.6 过程4：计算非参数估计的预测误差 4.7 过程5：计算条件方差估计时的参考谱宽 4.8 过程6：计算条件方差估计时的最优交叉验证谱宽 4.9 过程7：计算CEF估计的方差和标准差 参考文献", " Lab 4 局部线性估计及效率分析（工资案例） 4.1 实验说明 4.1.1 实验内容 实验目标：非参数局部线性回归估计及其效率分析，复现工资案例（包括Figure 19.5和Figure 19.6的全部过程及结果（参看：HANSEN B. Econometrics[M].2021（作者手稿）. 第19章 Nonparametric Regression. ） 主要内容包括： 局部线性回归方法（LLR）下，估计CEF\\(\\widehat{m}(x)\\)的最优谱宽\\(h\\)选择（经验法和交叉验证法） 局部线性回归方法（LLR）下，估计方差最优谱宽的选择 局部线性回归方法（LLR）的估计偏误、估计方差和标准差 局部线性回归估计（LLR）的显著性检验（置信区间） 4.1.2 材料准备 软件环境：编译器为Rstudio（要求R 4.1及以上版本） R代码文件：工作项目（R project）根目录下Rscript/文件夹内 # don&#39;t run here ! # only show you the code file path! source(here(&quot;Rscript/hensen21-fig19-5.R&quot;), encoding = &quot;UTF-8&quot;) source(here(&quot;Rscript/hensen21-fig19-5.R&quot;), encoding = &quot;UTF-8&quot;) 4.2 案例描述 4.2.1 工资案例：背景说明 案例基于CPS数据集，重点分析其中的子样本数据（黑人、男性、拥有12年受教育程度——高中毕业），样本数为n=100。 关注的问题：时均工资的对数（Y =log(wage)）对职业经历（X=experience）的非参数回归估计。 后面的分析中，我们会重点划定观测窗口为：职业经历（年数）范围为 \\([0,40]\\)。因为样本中90%以上的观测对象都落在这个范围之内。 4.2.2 读取案例数据 ## This file generates Figures 19.5 and 19.6 ## Wage/Experience #### attention 1/2 #### ## this is the part 1/2 R script of the whole analysis ## so you will run `hensen21-fig19-6.R` forthcoming # Uses data file cps09mar.dta dt_file &lt;- here::here(&quot;data/cps09mar.dta&quot;) dat &lt;- haven::read_dta(dt_file) # data set 1 # sub-sample of black men with 12 years of education bf &lt;- (dat[,11]==2)&amp;(dat[,2]==1)&amp;(dat[,4]==12) dat1 &lt;- dat[bf,] ## earning per hours y &lt;- as.matrix(log(dat1[,5]/(dat1[,6]*dat1[,7]))) x &lt;- as.matrix(dat1[,1]-dat1[,4]-6) n &lt;- length(y) dt_cps1 &lt;- tibble(X=x, Y=y) 4.2.3 数据呈现 dt_cps1 %&gt;% add_column(obs = 1:nrow(.), .before = &quot;X&quot;) %&gt;% DT::datatable( caption = paste0(&quot;CPS数据集(n=&quot;,n,&quot;)&quot;), options = list(dom = &quot;tip&quot;, pageLength =8))%&gt;% formatRound(c(3), digits = 4) 样本数据的描述性统计如下： summary(dt_cps1) X.age Y.earnings Min. :-2 Min. :-3.1 1st Qu.:15 1st Qu.: 2.2 Median :25 Median : 2.5 Mean :25 Mean : 2.5 3rd Qu.:34 3rd Qu.: 2.8 Max. :62 Max. : 4.0 4.2.4 数据散点图 #### basic plot #### fsize &lt;- 16 p0 &lt;- ggplot() + geom_point(aes(X, Y),data = dt_cps1, pch=21) + labs(x= &quot;X职业年数&quot;, y =&quot;log(Y)时均工资的对数&quot;) + scale_x_continuous(breaks = seq(0,70,10), limits = c(0,65)) + scale_y_continuous(breaks = seq(0,4,1), limits = c(0,4)) + theme_bw() + theme(text = element_text(size = fsize)) # show the scatter p0 图 4.1: 样本数据散点图n=r n 4.3 过程1：CEF估计的经验参考谱宽选择 4.3.1 R运算代码 我们先把经验参考谱宽的完整代码给出，后面我们再按分析流程进行步骤分解操作。 # Reference Rule sx1 &lt;- 0 # window range sx2 &lt;- 40 x1 &lt;- matrix(1,n,1) zz &lt;- cbind(x1,x,x^2,x^3,x^4) beta &lt;- solve((t(zz)%*%zz),(t(zz)%*%y)) xtrim &lt;- (x&lt;=sx2)*(x&gt;=sx1) b &lt;- mean(((beta[3]+x*3*beta[4]+(x^2)*6*beta[5])^2)*xtrim) e &lt;- y - zz%*%beta sig &lt;- (sum(e^2))/(n-5) hrot &lt;- 0.58*(((sx2-sx1)*sig/n/b)^.2) 4.3.2 过程步骤解读 下面我们按前述步骤来计算参考谱宽值 \\(h_{rot}\\)： 步骤1：根据案例数据集，设定权重取值范围 \\(\\left\\{\\xi_{1} \\leq x \\leq \\xi_{2}\\right\\}=\\{0,40\\}\\) 步骤2：构建多项式回归 varx &lt;- c(&quot;X&quot;,&quot;X^2&quot;,&quot;X^3&quot;,&quot;X^4&quot;) lx_out &lt;- xmerit::lx.psm(x = varx, n.row = 5) \\[\\begin{align} \\begin{split} Y_i=&amp;+\\beta_{1}+\\beta_{2}X_i+\\beta_{3}X^2_i+\\beta_{4}X^3_i+\\beta_{5}X^4_i+u_i \\end{split} \\end{align}\\] 直接使用OLS进行估计，得到估计方程： mod_poly &lt;- formula(&quot;Y~X +I(X^2) +I(X^3) +I(X^4)&quot; ) lx_est &lt;- xmerit::lx.est(lm.mod = mod_poly, lm.dt = dt_cps1, lm.n = 5, opt = c(&quot;s&quot;), digits = c(6,4,2,4)) \\[\\begin{equation} \\begin{alignedat}{999} &amp;\\widehat{Y}=&amp;&amp;+2.094395&amp;&amp;+0.030951X_i&amp;&amp;-0.000103X^2_i&amp;&amp;-0.000021X^3_i&amp;&amp;+0.000000X^4_i\\\\ &amp;(s)&amp;&amp;(0.1371)&amp;&amp;(0.0284)&amp;&amp;(0.0019)&amp;&amp;(0.0000)&amp;&amp;(0.0000) \\end{alignedat} \\end{equation}\\] 进而得到拟合值 \\(\\widehat{m}(x)\\)及其二阶导 \\(\\widehat{m}^{\\prime \\prime}(x)\\)及残差 \\(\\hat{\\epsilon}\\) \\[\\begin{align} \\widehat{m}(x) &amp;=2.094395+0.030951x_i-0.000103x^2_i-0.000021x^3_i+0.000000x^4_i \\\\ \\widehat{m}^{\\prime \\prime}(x) &amp;=-2\\times0.000103-6\\times0.000021x_i+12\\times0.000000x^2_i \\\\ \\end{align}\\] 步骤3：利用上述估计结果计算 \\[\\begin{align} \\widehat{B}=\\frac{1}{n} \\sum_{i=1}^{n}\\left(\\frac{1}{2} \\hat{m}^{\\prime \\prime}\\left(X_{i}\\right)\\right)^{2} \\mathbb{1}\\left\\{\\xi_{1} \\leq X_{i} \\leq \\xi_{2}\\right\\} = 0.00000025 \\end{align}\\] 步骤4：多项式模型的回归误差方差 \\[\\hat{\\sigma}^2 = \\frac{\\sum{\\hat{\\epsilon}^2}}{n-q-1}=0.2592\\] 步骤5：根据上述全部结果计算得到经验谱宽： \\[\\begin{align} h_{\\text {rot }}&amp;=0.58\\left(\\frac{\\widehat{\\sigma}^{2}\\left(\\xi_{2}-\\xi_{1}\\right)}{n \\widehat{B}}\\right)^{1 / 5} = 0.58 \\times \\left(\\frac{0.2592\\times \\left(40-0\\right)}{762 \\times 0.000000248}\\right)^{1 / 5} = 5.1442 \\end{align}\\] 4.4 过程2：CEF估计的最优交叉验证谱宽选择 4.4.1 R运算代码 注意：此代码运行时间较长（约3-5分钟），为提高渲染效率代码文件仅需运行一次。 #### CV Bandwidth Selection #### g &lt;- 200 h1 &lt;- hrot/3 h2 &lt;- 3*hrot hh &lt;- seq(h1,h2,(h2-h1)/g) hn &lt;- length(hh) LL &lt;- matrix(0,n,hn) for (i in 1:hn){ hi &lt;- hh[i] for (j in 1:n){ xj &lt;- x-x[j] k &lt;- dnorm(xj/hi) k[j] &lt;- 0 z &lt;- cbind(x1,xj) zk &lt;- z*(k%*%cbind(1,1)) beta &lt;- solve(t(zk)%*%z,t(zk)%*%y) LL[j,i] &lt;- (y[j]-beta[1])^2 } } LL2 &lt;- LL*(xtrim%*%matrix(1,1,hn)) cvLL &lt;- colMeans(LL2) i &lt;- which.min(cvLL) hLL &lt;- hh[i] hLL_tex &lt;-paste0(&quot;$h_{CV}=$&quot;,number(hLL,0.0001),&quot;&quot;) LLmin &lt;- min(cvLL) # combine result as data.frame tb_cvc &lt;- tibble( h_tune = hh, cv_LL = cvLL) 4.4.2 过程步骤解读 首先我们约定一下交叉验证谱宽的计算规则 步骤1：设定经验谱宽 \\(h_{rot}=5.1442\\)作为初始值。。 步骤2：设定调参谱宽（tuning bandwidth）。 &gt; 一个经验谱宽范围可供参考： \\([h_{rot}/3, 3h_{rot}]=[1.7147, 15.4326]\\)。 给定范围内的搜寻总数为 \\(n=201\\)。则待评估序贯值为 \\(h\\in (1.7147, 1.7833, 1.8519, 1.9205, 1.9891, \\cdots,15.2268, 15.2954, 15.3640, 15.4326)\\)。 下面我们就可以得到交叉验证谱宽的CV计算表： tb_cvc %&gt;% add_column(id = 1:nrow(.), .before = &quot;h_tune&quot;) %&gt;% DT::datatable(caption = &quot;LL方法下的CV计算表&quot;, options = list(dom =&quot;tip&quot;, pageLength =8)) %&gt;% formatRound(c(2:3), digits = 4) 4.4.3 图形展示选择结果 #### plot 19.5-a Cross-Validation Criterion #### lwd &lt;- 0.8 lwadd &lt;- 0.2 p_cvc &lt;- ggplot(aes(x = h_tune),data = tb_cvc) + geom_line(aes(y = cv_LL), lty = &quot;dashed&quot;, color = &quot;blue&quot;, lwd = lwd) + labs(x= &quot;谱宽h&quot;, y =&quot;交叉验证准则函数值CV(h)&quot;) + scale_x_continuous(#expand = expansion(add = c(0, .06)), breaks = seq(1,12,1), limits = c(1,12)) + scale_y_continuous( expand = expansion(add = c(0,0)), breaks = seq(0.2290,0.2310,0.0005), limits = c(0.2290,0.2310), labels = scales::number_format(accuracy = 0.0001) ) + geom_segment(aes(x=hLL, xend = hLL, y= LLmin, yend = c(0.2290)), arrow = arrow(length = unit(0.1,&quot;cm&quot;), type = &quot;closed&quot;), lty = &quot;dashed&quot;, color= &quot;gray&quot;, lwd=lwd) + geom_text(aes(x = hLL+0.5, y=LLmin-0.0004), label =latex2exp::TeX(hLL_tex), #parse=TRUE, color= &quot;blue&quot;, size=4) + theme_bw() + theme(text = element_text(size = fsize)) 下面，我们可以视觉化展示交叉验证谱宽与CV变化关系： p_cvc 4.5 过程3：基于不同谱宽选择的CEF估计 4.5.1 R运算代码 注意：此代码运行时间较长（约3-5分钟），为提高渲染效率代码文件仅需运行一次。 #### CEF LL Regression Estimation #### g &lt;- 201 xg &lt;- seq(sx1,sx2,(sx2-sx1)/(g-1)) m1 &lt;- matrix(0,g,1) m2 &lt;- matrix(0,g,1) for (j in 1:g){ xj &lt;- x-xg[j] z &lt;- cbind(x1,xj) z1 &lt;- z*(dnorm(xj/hrot)%*%cbind(1,1)) # use rot bandwidth z2 &lt;- z*(dnorm(xj/hLL)%*%cbind(1,1)) # use CV bandwidth beta1 &lt;- solve(t(z1)%*%z,t(z1)%*%y) beta2 &lt;- solve(t(z2)%*%z,t(z2)%*%y) m1[j,1] &lt;- beta1[1] m2[j,1] &lt;- beta2[1] } # combine result as data.frame tb_mxh &lt;- tibble(xg = xg, mx1=as.vector(m1), mx2=as.vector(m2)) 4.5.2 过程步骤解读 首先，我们给出两种谱宽选择（rot谱宽或者CV谱宽）下的CEF估计值（\\(\\widehat{m}(x)\\)）的最终计算表： tb_mxh %&gt;% add_column(index = 1:nrow(.), .before = &quot;xg&quot;) %&gt;% rename(&quot;mx_rot&quot;=&#39;mx1&#39;, &quot;mx_cv&quot;=&#39;mx2&#39;) %&gt;% DT::datatable(caption = &quot;使用不同谱宽下LL方法对m(x)的估计结果&quot;, options = list(dom =&quot;tip&quot;, pageLength =8)) %&gt;% formatRound(c(2,3:4), digits = c(2,4,4)) 4.5.3 图形展示估计结果 根据上述计算表，我们首先图形化展示在局部线性回归方法下（LLR）使用ROT谱宽估计得到的\\(\\widehat{m}(x)\\)： #### plot 19.5-b Local Linear Regression #### # basic plot p00 &lt;- ggplot() + geom_point(aes(X, Y),data = dt_cps1, pch=21,alpha =0.1) + labs(x= &quot;X职业年数&quot;, y =&quot;log(Y)时均工资的对数&quot;) + scale_x_continuous(breaks = seq(0,40,5), limits = c(0,40)) + scale_y_continuous(breaks = seq(2,2.7,0.1), limits = c(2,2.7)) + theme_bw() + theme(text = element_text(size = fsize)) # plot mx with h_rot p_mxh1 &lt;- p00 + geom_line(aes(x = xg, y = m1, color=&quot;m1&quot;, lty=&quot;m1&quot;), lwd = lwd+lwadd, data = tb_mxh) + theme_bw() + scale_color_manual( name=&quot;&quot;, breaks = c(&quot;m1&quot;), labels = c(expression(m(x):h[ROT])), values=c(&quot;green&quot;))+ scale_linetype_manual( name=&quot;&quot;, breaks = c(&quot;m1&quot;), labels = c(expression(m(x):h[ROT])), values=c(&quot;dotted&quot;))+ theme(legend.position = &quot;right&quot;, text = element_text(size = fsize)) p_mxh1 然后，我们再图形化展示在局部线性回归方法下（LLR）使用最优CV谱宽估计得到的\\(\\widehat{m}(x)\\)： # plot mx with h_CV p_mxh2 &lt;- p00 + geom_line(aes(x = xg, y = m2, color=&quot;m2&quot;, lty=&quot;m2&quot;), lwd = lwd+lwadd, data = tb_mxh) + scale_color_manual( name=&quot;&quot;, breaks = c(&quot;m2&quot;), labels = c(expression(m(x):h[CV])), values=c(&quot;blue&quot;))+ scale_linetype_manual( name=&quot;&quot;, breaks = c(&quot;m2&quot;), labels = c(expression(m(x):h[CV])), values=c(&quot;dashed&quot;))+ theme(legend.position = &quot;right&quot;, text = element_text(size = fsize)) p_mxh2 当然，最后我们可以对使用两种谱宽选择（rot谱宽或者CV谱宽）下的CEF估计值（\\(\\widehat{m}(x)\\)）做图形对比： # plot mx with both h selections p_mxh &lt;- p00 + geom_line(aes(x = xg, y = m1, color=&quot;m1&quot;, lty=&quot;m1&quot;), lwd = lwd+lwadd, data = tb_mxh) + geom_line(aes(x = xg, y = m2, color=&quot;m2&quot;, lty=&quot;m2&quot;), lwd = lwd+lwadd, data = tb_mxh) + scale_color_manual( name=&quot;&quot;, breaks = c(&quot;m1&quot;, &quot;m2&quot;), labels = c(expression(m(x):h[ROT]),expression(m(x):h[CV])), values=c(&quot;green&quot;, &quot;blue&quot;))+ scale_linetype_manual( name=&quot;&quot;, breaks = c(&quot;m1&quot;, &quot;m2&quot;), labels = c(expression(m(x):h[ROT]),expression(m(x):h[CV])), values=c(&quot;dotted&quot;, &quot;dashed&quot;))+ theme(legend.position = &quot;right&quot;, text = element_text(size = fsize)) p_mxh 4.6 过程4：计算非参数估计的预测误差 注意：至此以下的代码块，我们需要开始执行hensen21-fig19-6.R文件里的R命令！ # don&#39;t run here ! # only show you the code file path! source(here(&quot;Rscript/hensen21-fig19-5.R&quot;), encoding = &quot;UTF-8&quot;) source(here(&quot;Rscript/hensen21-fig19-6.R&quot;), encoding = &quot;UTF-8&quot;) 4.6.1 R运算代码 ## This file generates Figures 19.5 and 19.6 ## Wage/Experience #### attention 2/2 #### ## this is the part 2/2 R script ## so you should run `hensen21-fig19-5.R` firstly #### ROT Residual Estimation #### h &lt;- hrot e2 &lt;- matrix(0,n,1) for (j in 1:n){ xj &lt;- x-x[j] k &lt;- dnorm(xj/h) k[j] &lt;- 0 z &lt;- cbind(x1,xj) zk &lt;- z*(k%*%cbind(1,1)) beta &lt;- solve(t(zk)%*%z,t(zk)%*%y) e2[j,1] &lt;- (y[j]-beta[1])^2 # get square residual here } 4.6.2 过程步骤解读 （1）获得预测残差 我们首先可以计算得到LL估计下的预测残差的平方 \\(\\tilde{e}^2_i\\) 这一步可以直接采用前述的参考谱宽 \\(h_{rot}=5.1442\\) 运行上述代码即可得到预测残差的平方\\(e_i^2\\) 4.7 过程5：计算条件方差估计时的参考谱宽 4.7.1 R运算代码 #### Variance ROT Bandwidth #### beta &lt;- solve((t(zz)%*%zz),(t(zz)%*%e2)) b &lt;- mean(((beta[3]+x*3*beta[4]+(x^2)*6*beta[5])^2)*xtrim) e &lt;- e2 - zz%*%beta sig &lt;- (sum(e^2))/(n-5) hrotv &lt;- 0.58*(((sx2-sx1)*sig/n/b)^.2) 4.7.2 过程步骤解读 （2）再次获得参考谱宽： 后面我们还要计算方差估计下的最优谱宽。因此，这里我们需要再进行一次参考谱宽的计算流程。 构建残差平方的多项式回归模型 \\[\\begin{align} \\begin{split} \\tilde{e}^2_i=&amp;+\\gamma_{0}+\\gamma_{1}X_i+\\gamma_{2}X^2_i+\\gamma_{3}X^3_i+\\gamma_{4}X^4_i+v_i \\end{split} \\end{align}\\] 利用ROT公式流程，再次获得参考谱宽 \\[\\begin{align} hv_{\\text {rot }}&amp;=0.58\\left(\\frac{\\widehat{\\sigma}^{2}\\left(\\xi_{2}-\\xi_{1}\\right)}{n \\widehat{B}}\\right)^{1 / 5} = 0.58 \\times \\left(\\frac{1.2384\\times \\left(40-0\\right)}{762 \\times 0.000000300}\\right)^{1 / 5} = 6.7708 \\end{align}\\] 4.8 过程6：计算条件方差估计时的最优交叉验证谱宽 4.8.1 R运算代码 注意：此代码运行时间较长（约3-5分钟），为提高渲染效率代码文件仅需运行一次。 #### Variance CV Bandwidth Selection #### h1 &lt;- 2 h2 &lt;- 40 hh &lt;- seq(h1,h2,(h2-h1)/g) hn &lt;- length(hh) LLV &lt;- matrix(0,n,hn) NWV &lt;- matrix(0,n,hn) for (i in 1:hn){ hi &lt;- hh[i] for (j in 1:n){ xj &lt;- x-x[j] k &lt;- dnorm(xj/hi) k[j] &lt;- 0 mu &lt;- (t(k)%*%e2)/sum(k) NWV[j,i] &lt;- (e2[j]-mu)^2 z &lt;- cbind(x1,xj) zk &lt;- z*(k%*%cbind(1,1)) beta &lt;- solve(t(zk)%*%z,t(zk)%*%e2) LLV[j,i] &lt;- (e2[j]-beta[1])^2 } } cvNWV &lt;- colMeans(NWV*(xtrim%*%matrix(1,1,hn))) cvLLV &lt;- colMeans(LLV*(xtrim%*%matrix(1,1,hn))) i1 &lt;- which.min(cvNWV) i2 &lt;- which.min(cvLLV) hNWV &lt;- hh[i1] hLLV &lt;- hh[i2] hNWV_tex &lt;-paste0(&quot;$h_{NW}=$&quot;,number(hNWV,0.1),&quot;&quot;) hLLV_tex &lt;-paste0(&quot;$h_{CV}=$&quot;,number(hLLV,0.1),&quot;&quot;) NWminV &lt;- min(cvNWV) LLminV &lt;- min(cvLLV) # combine all result tbl_cvcv &lt;- tibble( h_tune = hh, cv_NW = cvNWV, cv_LL = cvLLV) 4.8.2 过程步骤解读 （3）再次获得最优交叉验证谱宽：然后开始计算方差估计下的最优谱宽。这里我们再进行一次交叉验证谱宽的计算流程。 步骤1：设定经验谱宽 \\(hv_{rot}=6.7708\\)作为初始值。。 步骤2：设定调参谱宽（tuning bandwidth）。 &gt; 一个经验谱宽范围可供参考： \\([2.0, 40.0]\\)。 给定范围内的搜寻总数为 \\(n=202\\)。则待评估序贯值为 \\(h\\in (2.0000, 2.1891, 2.3781, 2.5672, 2.7562, \\cdots,39.4328, 39.6219, 39.8109, 40.0000)\\)。 步骤3：采用交叉验证留一法，分别遍历计算NW估计和LL估计下的全部CV值（见后面计算表） 步骤4：最小CV值对应的谱宽评估值，则为最优交叉验证谱宽。当然，我们最终发现NW估计和LL估计下的结果是一样的，都选择了最大边界值 \\(hv_{CV}(NW)=hv_{CV}(LL)=40\\)。（见后面的CV比较图） 最后我们就可以得到，NW和LL方法下的CV值计算表（附表）： tbl_cvcv %&gt;% add_column(id = 1:nrow(.), .before = &quot;h_tune&quot;) %&gt;% DT::datatable(caption = &quot;NW和LL方法下的CV计算表&quot;, options = list(dom =&quot;tip&quot;, pageLength =8)) %&gt;% formatRound(c(2:4), digits = 4) 4.8.3 图形展示谱宽选择结果 基于上述计算，我们最终得到NW和LL方法下方差估计的CV值与谱宽关系（制图代码及附图）： #### plot 19.6-a Cross-Validation Criterion #### ## Cross-Validation for Conditional Variance p_cvcv &lt;- ggplot(aes(x = h_tune),data = tbl_cvcv) + geom_line(aes(y = cv_NW, lty = &quot;CV_NW&quot;, color = &quot;CV_NW&quot;), lwd = lwd) + geom_line(aes(y = cv_LL, lty = &quot;CV_LL&quot;, color = &quot;CV_LL&quot;), lwd = lwd) + labs(x= &quot;谱宽h&quot;, y =&quot;交叉验证准则函数值CV(h)&quot;) + scale_x_continuous(#expand = expansion(add = c(0, .06)), breaks = seq(0,40,5), limits = c(0,40)) + scale_y_continuous(expand = expansion(add = c(0,0)), breaks = seq(1.200, 1.216,0.004), limits = c(1.200, 1.216), labels = scales::number_format(accuracy = 0.001) ) + theme_bw() + geom_segment(aes(x=hNWV, xend = hNWV, y= NWminV, yend = 1.2), arrow = arrow(length = unit(0.1,&quot;cm&quot;), type = &quot;closed&quot;), lty = &quot;dotted&quot;, color= &quot;gray&quot;, lwd=lwd) + geom_text(aes(x = hNWV-2, y=NWminV-0.002), label =latex2exp::TeX(hNWV_tex), color= &quot;orange&quot;, size=3) + geom_segment(aes(x=hLLV, xend = hLLV, y= LLminV, yend = 1.2), arrow = arrow(length = unit(0.1,&quot;cm&quot;), type = &quot;closed&quot;), lty = &quot;dashed&quot;, color= &quot;gray&quot;, lwd=lwd) + geom_text(aes(x = hLLV-2, y=LLminV-0.002), label =latex2exp::TeX(hLLV_tex), color= &quot;blue&quot;, size=3) + scale_color_manual( name=&quot;&quot;, breaks = c(&quot;CV_NW&quot;, &quot;CV_LL&quot;), values=c(&quot;orange&quot;, &quot;blue&quot;))+ scale_linetype_manual( name=&quot;&quot;, breaks = c(&quot;CV_NW&quot;, &quot;CV_LL&quot;), values=c(&quot;dotted&quot;, &quot;dashed&quot;))+ theme(legend.position = &quot;right&quot;) p_cvcv LL估计的CV值在局部上具有最小值，也即局部最优谱宽约为 \\(hv_{cv}(LL)\\simeq 5\\) 但是从全局来看，无论是NW估计，还是LL估计，CV函数值都表现为下降趋势。因此它们都选择了最大边界值 \\(hv_{CV}(NW)=hv_{CV}(LL)=40\\)。 4.9 过程7：计算CEF估计的方差和标准差 4.9.1 R运算代码 #### Variance Estimation #### se &lt;- matrix(0,g,1) u &lt;- cbind(e2,e2) for (j in 1:g){ xj &lt;- x-xg[j] z &lt;- cbind(x1,xj) K &lt;- dnorm(xj/hrot) z1 &lt;- z*cbind(K,K) ZKZ &lt;- solve(t(z1)%*%z) ZK2 &lt;- t(z1)%*%(z1*u) V1 &lt;- ZKZ%*%ZK2%*%ZKZ se[j,1] = sqrt(V1[1,1]) } L1 &lt;- m1-1.96*se U1 &lt;- m1+1.96*se # combine all result as data.frame tbl_band &lt;- tibble( xg =xg, mx = m1, s=as.vector(se), s2=se^2, lwr = L1, upr = U1 ) 4.9.2 过程步骤解读 （4）计算方差、标准差。利用前面的平方预测误差，并使用谱宽 \\(h=5.1442\\)进行LL估计，最终得到方差和标准差估计值（见后面附表）。 \\[\\begin{align} \\widehat{\\boldsymbol{V}}_{\\widehat{\\beta}}(x)=\\left(\\boldsymbol{Z}^{\\prime} \\boldsymbol{K} \\boldsymbol{Z}\\right)^{-1}\\left(\\sum_{i=1}^{n} K\\left(\\frac{X_{i}-x}{h}\\right)^{2} Z_{i}(x) Z_{i}(x)^{\\prime} \\widetilde{\\boldsymbol{e}}_{i}^{2}\\right)\\left(\\boldsymbol{Z}^{\\prime} \\boldsymbol{K} \\boldsymbol{Z}\\right)^{-1} \\end{align}\\] 同时，我们将计算得到CEF估计值\\(\\widehat{m}(x)\\)的估计方差和估计标准误（见如下计算附表）： tbl_band %&gt;% add_column(id = 1:nrow(.), .before = &quot;xg&quot;) %&gt;% DT::datatable(caption = &quot;LL方法下的方差和标准差、置信区间&quot;, options = list(dom =&quot;tip&quot;, pageLength =8)) %&gt;% formatRound(c(3:7), digits = 4) （5）计算置信区间和置信带。进一步计算逐点置信区间（Pointwise Conﬁdence Interval）（见前面附表），并得到置信带（见后面附图）。 \\[\\begin{align} \\widehat{m}(x) \\pm z_{1-\\alpha/2}(n-1) \\cdot \\sqrt{\\widehat{V}_{\\widehat{m}(x)}}\\\\ \\widehat{m}(x) \\pm 1.96 \\sqrt{\\widehat{V}_{\\widehat{m}(x)}} \\end{align}\\] 4.9.3 图形展示置信带 利用前述数据和置信区间机选公式，最总我们可以得到LLR方法下CEF估计量\\(\\widehat{m}(x)\\)的估计置信区间和置信带（附图） #### Plot 19.6-b Confidence Bands #### p_band &lt;- p00 + geom_line(aes(x = xg, y = mx), data = tbl_band, color = &quot;blue&quot;, lty = &quot;solid&quot;, lwd = lwd) + geom_ribbon(aes(x=xg,ymin = lwr, ymax = upr), data = tbl_band, alpha = 0.2) p_band 参考文献 "],["lab-srdd-nocovs.html", "Lab 5 无协变量的SRDD效应分析（儿童死亡率案例） 5.1 实验说明 5.2 案例描述 5.3 过程1：设定相关参数和辅助计算工具 5.4 过程2：进行RDD估计运算（R代码） 5.5 过程3：将RDD估计结果整理成相关表格 5.6 过程4：绘制RDD分析图（mx估计值） 5.7 过程5：绘制RDD置信带图 5.8 RDD分析的过程步骤解读 5.9 过程6：等价线性回归 参考文献", " Lab 5 无协变量的SRDD效应分析（儿童死亡率案例） 5.1 实验说明 5.1.1 实验内容 实验目标：无协变量情形下，对骤变RDD的局部线性回归估计进行分析，复现儿童死亡率案例（包括Figure 21.1b的全部过程及结果（参看：HANSEN B. Econometrics[M].2021（作者手稿）. 第21章 Regression Discontinuity. ） 主要内容包括： 无协变量情形下，基于骤变RDD（SRDD）模型，使用局部线性回归方法（LLR），估计断点处置效应ATE（\\(\\widehat{\\theta}\\)）及其估计标准误。 5.1.2 材料准备 软件环境：编译器为Rstudio（要求R 4.1及以上版本） R代码文件：工作项目（R project）根目录下Rscript/文件夹内 # don&#39;t run here ! # only show you the code file path! source(&quot;../Rscript/hansen21-fig21-1b.R&quot;, encoding = &quot;UTF-8&quot;) 注意：上述代码运行时间较长（约3-5分钟），为提高渲染效率代码文件仅需运行一次。 5.2 案例描述 5.2.1 死亡率案例：背景说明 援助项目与儿童死亡率： 案例基于(Ludwig J 等, 2007)的研究，他们重点评估了美国联邦政府脱贫援助项目（Head Start）的骤变RDD政策效应。 该援助项目于1965年实施，为3-5岁贫困孩子及其家庭提供学前教育、健康和社会服务等方面的资金援助。对于该援助项目经费，联邦政府将决定通过公开竞标，分配给提交援助申请的中标县。 为了保障援助项目的针对性，联邦政府将重点考虑资助被认定的300个贫困县。其中贫困县是基于1960年美国统计测度得到的贫困线水平（poverty rate）予以划定。 最终，300个贫困县中，有80%的县获得了项目资助；而其他提交申请的县中（非贫困县），有43%的县也获得了项目资助。 (Ludwig J 等, 2007)重点关注援助项目对中长期儿童死亡率影响。其中儿童死亡率定义为：1973-1983年间、儿童年龄范围在8-18岁、儿童死亡原因为Head Start定义的相关原因（如结核病等）。因而而援助项目希望努力消减这些儿童死亡情形的发生。 我们关注的问题：脱贫援助项目（Head Start）对儿童死亡率（Y=mortality rate）的因果效应。我们将采用骤变RDD非参数回归估计，运行变量为县贫困率（X=poverty rate），断点值(cut-off)设定为 \\(c=59.1984\\)。将使用子样本数据的样本数为\\(n=2783\\)。 5.2.2 读取案例数据 ## This file generates Figure 21.1b, Table 21.1 Baseline, and equation (21.5) ## Head Start Regression Discontinuity #### The data file LM2007.dta is used #### library(haven) library(here) dt_path &lt;- here::here(&quot;data/LM2007.dta&quot;) dat &lt;- read_dta(dt_path) y &lt;- dat$mort_age59_related_postHS x &lt;- dat$povrate60 c &lt;- 59.1984 dt_head &lt;- tibble(X= x, Y = y) %&gt;% mutate(D= ifelse(X&gt;=c,1,0)) 5.2.3 数据呈现 dt_head %&gt;% add_column(obs = 1:nrow(.), .before = &quot;X&quot;) %&gt;% DT::datatable( caption = paste0(&quot;援助项目数据集(n=2783)&quot;), options = list(dom = &quot;tip&quot;, pageLength =8))%&gt;% formatRound(c(2:3), digits = 4) 样本数据的描述性统计如下： summary(dt_head) X Y D Min. :15 Min. : 0 Min. :0.00 1st Qu.:24 1st Qu.: 0 1st Qu.:0.00 Median :34 Median : 0 Median :0.00 Mean :37 Mean : 2 Mean :0.11 3rd Qu.:47 3rd Qu.: 3 3rd Qu.:0.00 Max. :82 Max. :136 Max. :1.00 5.2.4 数据分组描述性统计 我们根据处置变量D进行数据分组，并进行描述性统计，统计分析代码如下： smry_grouped &lt;- dt_head %&gt;% group_by(D) %&gt;% dplyr::summarize(n = n(), x_mean = mean(X, na.rm =T), x_min = min(X,na.rm = T), x_max = max(X, na.rm = T), x_sd = sd(X), y_mean = mean(Y, na.rm =T), y_min = min(Y,na.rm = T), y_max = max(Y, na.rm = T), y_sd = sd(Y) ) %&gt;% pivot_longer(names_to = &quot;stat&quot;, values_to = &quot;value&quot;, -D) %&gt;% pivot_wider(names_from = D, values_from = value) %&gt;% rename_all(., ~c(&quot;stats&quot;,&quot;D0&quot;,&quot;D1&quot;)) 处置组和控制组描述性统计表如下： smry_grouped %&gt;% DT::datatable( caption = paste0(&quot;处置组和控制组描述性统计&quot;), options = list(dom = &quot;tip&quot;, pageLength =10, scrollX = TRUE))%&gt;% formatRound(c(2:3), digits = 2) 5.2.5 数据散点图 #### basic plot #### lwd &lt;- 0.6 fsize &lt;- 16 p0 &lt;- ggplot() + geom_point(aes(X, Y),data = dt_head, pch=21,alpha=0.6) + geom_vline(aes(xintercept=c), color = &quot;orange&quot;, lty = &quot;dotted&quot;, lwd=lwd) + labs(x= &quot;X贫困线&quot;, y =&quot;Y儿童死亡率&quot;) + scale_y_continuous(breaks = seq(0,80,20), limits = c(0,80)) + scale_x_continuous(breaks = seq(10,90,10), limits = c(10,90)) + theme_bw() + theme(text = element_text(size = fsize)) # show the scatter p0 图 5.1: 样本数据散点图n=r n 5.3 过程1：设定相关参数和辅助计算工具 5.3.1 R运算代码 考虑到对断点两侧的数据，我们要多次进行局部线性估计（LLR）、计算预测误差、计算标准误（从而计算置信区间），因此我们可以事先设计并封装好一些有用的辅助函数（辅助工具）。 为了简化计算，我们这里不再进行LLR的最优谱宽选择过程，而是直接先验设定好一个初始值（\\(h=8\\)）。 我们会多次分别对断点两侧运用LLR估计流程（我们已经在非参数局部回归估计中学习过了！） #### RDD Helper function #### # specify parameters and basic calculation h &lt;- 8 T &lt;- as.numeric(x &gt;= c) y1 &lt;- y[T==0] y2 &lt;- y[T==1] x1 &lt;- x[T==0] x2 &lt;- x[T==1] n1 &lt;- length(y1) n2 &lt;- length(y2) n &lt;- n1+n2 # set bins for both side g1 &lt;- seq(15,59.2,.2) g2 &lt;- seq(59.2,82,.2) G1 &lt;- length(g1) G2 &lt;- length(g2) # Helper function for triangle kernel function TriKernel &lt;- function(x) { s6 &lt;- sqrt(6) ax &lt;- abs(x) f &lt;- (1-ax/s6)*(ax &lt; s6)/s6 return(f) } # Helper function for LLR estimation LL_EST &lt;- function(y,x,g,h) { G &lt;- length(g) m &lt;- matrix(0,G,1) z &lt;- matrix(1,length(y),1) for (j in 1:G){ xj &lt;- x-g[j] K &lt;- TriKernel(xj/h) zj &lt;- cbind(z,xj) zz &lt;- t(cbind(K,xj*K)) beta &lt;- solve(zz%*%zj,zz%*%y) m[j] &lt;- beta[1] } return(m) } # Helper function for forecast residuals LL_Residual &lt;- function(y,x,h) { n &lt;- length(y) e &lt;- matrix(0,n,1) z &lt;- matrix(1,n,1) for (j in 1:n){ xj &lt;- x-x[j] K &lt;- TriKernel(xj/h) K[j] &lt;- 0 zj &lt;- cbind(z,xj) zz &lt;- t(cbind(K,xj*K)) beta &lt;- solve(zz%*%zj,zz%*%y) e[j] &lt;- y[j] - beta[1] } return(e) } # Helper function for standard error LL_SE &lt;- function(y,x,g,h) { G &lt;- length(g) s &lt;- matrix(0,G,1) z &lt;- matrix(1,length(y),1) e &lt;- LL_Residual(y,x,h) # used inner for (j in 1:G){ xj &lt;- x-g[j] K &lt;- TriKernel(xj/h) zj &lt;- cbind(z,xj) zz &lt;- cbind(K,xj*K) ZKZ &lt;- solve(t(zz)%*%zj) Ke &lt;- K*e ze &lt;- cbind(Ke,xj*Ke) V &lt;- ZKZ%*%crossprod(ze)%*%ZKZ s[j] = sqrt(V[1,1]) } return(s) } 5.3.2 过程步骤解读 谱宽选择及CEF估计的规则策略如下： 规则1：我们设定先验谱宽为 \\(h=8\\)，断点值设定为 \\(c =59.1984\\%\\)。 规则2：分别设定断点两边箱组中心点序列值（center of bins）。我们将采用非对称箱组设置方法： 控制组（断点左边）的评估范围为 \\([15, 59.2]\\)，序列间隔为0.2。评估总箱组数为 \\(g1=222\\)，待评估序列值为 \\(15.0, 15.2, 15.4, 15.6, 15.8, \\cdots,58.6, 58.8, 59.0, 59.2\\)。 处置组（断点右边）的评估范围为 \\([59.2, 82]\\)，序列间隔为0.2。评估总箱组数为 \\(g2=115\\)，待评估序列值为 \\(59.2, 59.4, 59.6, 59.8, 60.0, \\cdots,81.4, 81.6, 81.8, 82.0\\)。 规则3：基于三角核函数（triangle kenerl）采用局部线性估计法，分别对断点两侧进行条件期望函数CEF \\(m(x)\\)进行估计，并得到估计值 \\(\\widehat{m}(x)\\) 5.4 过程2：进行RDD估计运算（R代码） #### RDD Estimation #### # set bins for both side g1 &lt;- seq(15,59.2,.2) g2 &lt;- seq(59.2,82,.2) G1 &lt;- length(g1) G2 &lt;- length(g2) # estimate m(x) for both side m1 &lt;- LL_EST(y1,x1,g1,h) m2 &lt;- LL_EST(y2,x2,g2,h) # obtain standard error and interval for both side s1 &lt;- LL_SE(y1,x1,g1,h) s2 &lt;- LL_SE(y2,x2,g2,h) L1 &lt;- m1-1.96*s1 U1 &lt;- m1+1.96*s1 L2 &lt;- m2-1.96*s2 U2 &lt;- m2+1.96*s2 # rdd effect theta_lft &lt;- m1[G1] # m(x) for left cut-off theta_rgt &lt;- m2[1] # m(x) for right cut-off theta &lt;- m2[1]-m1[G1] # the ATE rdd effect v_g1 &lt;- s1[G1]^2 v_g2 &lt;- s2[1]^2 # t test setheta &lt;- sqrt(s1[G1]^2 + s2[1]^2) tstat &lt;- theta/setheta pvalue &lt;- 2*(1-pnorm(abs(tstat))) 5.5 过程3：将RDD估计结果整理成相关表格 5.5.1 将断点两侧的m(x)估计结果整理成表格（R代码） #### tibble of mx estimate related #### tbl_mx1 &lt;- tibble(group = &quot;control&quot;, xg = g1, mx=as.vector(m1), s = as.vector(s1), lwr = as.vector(L1), upr = as.vector(U1)) tbl_mx2 &lt;- tibble(group = &quot;treat&quot;, xg = g2, mx=as.vector(m2), s = as.vector(s2), lwr = as.vector(L2), upr = as.vector(U2)) tb_mxh &lt;- bind_rows(tbl_mx1, tbl_mx2) 5.5.2 将最终RDD断点效应整理成表格（R代码） #### tibble of estimate result #### tbl_theta01 &lt;- tibble( model = &quot;baseline&quot;, pars = c(&quot;theta&quot;), est = c(theta), se = c(setheta) ) 5.6 过程4：绘制RDD分析图（mx估计值） 5.6.1 对绘制底图（R代码） #### plot CEF mx #### lwd &lt;- 0.6 lwadd &lt;- 0.2 # basic plot p00 &lt;- ggplot() + geom_point(aes(X, Y),data = dt_head, pch=21,alpha=0.3) + geom_vline(aes(xintercept=c), color = &quot;red&quot;, lty = &quot;dotted&quot;, lwd=lwd) + labs(x= &quot;X贫困线&quot;, y =&quot;Y儿童死亡率&quot;) + scale_y_continuous(breaks = seq(0,5,1), limits = c(0,5)) + scale_x_continuous(breaks = seq(10,85,10), limits = c(10,85)) + theme_bw() + theme(text = element_text(size = fsize)) 5.6.2 对断点左边绘制mx估计图（R代码） # mx plot for left part p_mxh1 &lt;- p00 + geom_line(aes(x = xg, y = mx, color=&quot;m1&quot;, lty=&quot;m1&quot;), lwd = lwd+lwadd, data = base::subset(tb_mxh,group==&quot;control&quot;)) + #theme_bw() + scale_color_manual( name=&quot;&quot;, breaks = c(&quot;m1&quot;), labels = c(expression(m(x):control)), values=c(&quot;purple&quot;))+ scale_linetype_manual( name=&quot;&quot;, breaks = c(&quot;m1&quot;), labels = c(expression(m(x):control)), values=c(&quot;solid&quot;))+ theme(legend.position = &quot;right&quot;, text = element_text(size = fsize)) 5.6.3 对断点右边绘制mx估计图（R代码） # mx plot for right part p_mxh2 &lt;- p00 + geom_line(aes(x = xg, y = mx, color=&quot;m2&quot;, lty=&quot;m2&quot;), lwd = lwd+lwadd, data = base::subset(tb_mxh,group==&quot;treat&quot;)) + scale_color_manual( name=&quot;&quot;, breaks = c(&quot;m2&quot;), labels = c(expression(m(x):treat)), values=c(&quot;blue&quot;))+ scale_linetype_manual( name=&quot;&quot;, breaks = c(&quot;m2&quot;), labels = c(expression(m(x):treat)), values=c(&quot;solid&quot;))+ theme(legend.position = &quot;right&quot;, text = element_text(size = fsize)) 5.6.4 同时对断点两边绘制mx估计图（R代码） # mx plot for both side p_mxh &lt;- p00 + geom_line(aes(x = xg, y = mx, color=&quot;m1&quot;, lty=&quot;m1&quot;), lwd = lwd+lwadd, data = base::subset(tb_mxh,group==&quot;control&quot;)) + geom_line(aes(x = xg, y = mx, color=&quot;m2&quot;, lty=&quot;m2&quot;), lwd = lwd+lwadd, data = base::subset(tb_mxh,group==&quot;treat&quot;)) + scale_color_manual( name=&quot;&quot;, breaks = c(&quot;m1&quot;, &quot;m2&quot;), labels = c(expression(m(x):control),expression(m(x):treat)), values=c(&quot;purple&quot;, &quot;blue&quot;))+ scale_linetype_manual( name=&quot;&quot;, breaks = c(&quot;m1&quot;, &quot;m2&quot;), labels = c(expression(m(x):control),expression(m(x):treat)), values=c(&quot;solid&quot;, &quot;solid&quot;))+ theme(legend.position = &quot;right&quot;) 5.7 过程5：绘制RDD置信带图 5.7.1 对断点左边绘制置信带（R代码） #### Plot Confidence Bands #### # band plot for left side p_band_left &lt;- p_mxh1 + geom_ribbon(aes(x=xg,ymin = lwr, ymax = upr), data = base::subset(tb_mxh,group==&quot;control&quot;), alpha = 0.2) 5.7.2 对断点右边绘制置信带（R代码） # band plot for right side p_band_right &lt;- p_mxh2 + geom_ribbon(aes(x=xg,ymin = lwr, ymax = upr), data = base::subset(tb_mxh,group==&quot;treat&quot;), alpha = 0.2) 5.7.3 对断点两边同时绘制置信带（R代码） # band plot for both side p_band &lt;- p_mxh + geom_ribbon(aes(x=xg,ymin = lwr, ymax = upr), data = base::subset(tb_mxh,group==&quot;control&quot;), alpha = 0.2) + geom_ribbon(aes(x=xg,ymin = lwr, ymax = upr), data = base::subset(tb_mxh,group==&quot;treat&quot;), alpha = 0.2) + geom_text(aes(x = c-3, y = theta_lft, label=number(theta_lft, 0.0001)), color = &quot;purple&quot;)+ geom_text(aes(x = c+3, y = theta_rgt, label=number(theta_rgt, 0.0001)), color = &quot;blue&quot;) + geom_segment(aes(x=c, xend = c, y= theta_lft, yend = theta_rgt), arrow = arrow(length = unit(0.1,&quot;cm&quot;), type = &quot;closed&quot;), lty = &quot;solid&quot;, color= &quot;orange&quot;, lwd=lwd) + geom_text(aes(x = c+5, y=theta_lft+0.5*theta), label = TeX(paste0(&quot;\\\\hat{\\\\theta}=&quot;,number(theta,0.0001))), color= &quot;orange&quot;, size=4) 5.7.4 额外辅助绘图函数（R代码） 为了与后面加入协变量的RDD模型做图形对比，我们有必要在这里提前做好功课！！ 这里暂时用不上，但是后面的“协变量RDD”部分就会用到啦！ 具体为什么要这样做，原因有点绕吗，这里就先不做解释喽！！ # wrapper function to avoid two .R file&#39;s global variable conflict ## when use `include_graphics()` after a new global env ## see [url](https://www.r-bloggers.com/2020/08/why-i-dont-use-r-markdowns-ref-label/) draw_band &lt;- function(p_base=p_mxh, df=tb_mxh, theta=theta,theta_lft = theta_lft, theta_rgt = theta_rgt){ p &lt;- p_base + geom_ribbon(aes(x=xg,ymin = lwr, ymax = upr), data = base::subset(df,group==&quot;control&quot;), alpha = 0.2) + geom_ribbon(aes(x=xg,ymin = lwr, ymax = upr), data = base::subset(df,group==&quot;treat&quot;), alpha = 0.2) + geom_text(aes(x = c-3, y = theta_lft, label=number(theta_lft, 0.0001)), color = &quot;purple&quot;)+ geom_text(aes(x = c+3, y = theta_rgt, label=number(theta_rgt, 0.0001)), color = &quot;blue&quot;) + geom_segment(aes(x=c, xend = c, y= theta_lft, yend = theta_rgt), arrow = arrow(length = unit(0.1,&quot;cm&quot;), type = &quot;closed&quot;), lty = &quot;solid&quot;, color= &quot;orange&quot;, lwd=lwd) + geom_text(aes(x = c+5, y=theta_lft+0.5*theta), label = TeX(paste0(&quot;\\\\hat{\\\\theta}=&quot;,number(theta,0.0001))), color= &quot;orange&quot;, size=4) return(p) } theta_lft1 &lt;- theta_lft theta_rgt1 &lt;- theta_rgt theta1 &lt;- theta p_band_wrapper &lt;- draw_band(p_base=p_mxh, df=tb_mxh, theta=theta1,theta_lft = theta_lft1, theta_rgt = theta_rgt1) 5.8 RDD分析的过程步骤解读 5.8.1 条件期望函数CEF m(x)的LLR估计结果 首先，我们可以计算得到条件期望函数CEF m(x)的LLR估计值数据表： tb_mxh %&gt;% add_column(index = 1:nrow(.), .before = &quot;xg&quot;) %&gt;% select(index,group, xg,mx) %&gt;% DT::datatable(caption = &quot;局部线性估计LL方法对m(x)的估计结果&quot;, options = list(dom =&quot;tip&quot;, pageLength =8, scrollX = TRUE)) %&gt;% formatRound(c(3), digits = c(1))%&gt;% formatRound(c(4), digits = c(4)) 基于此，我们可以分别得到CEF m(x)在断点左侧（控制组）的估计图 p_mxh1 图 5.2: m(x)在断点左侧（控制组）的估计图 类似地，也可以得到CEF m(x)在断点右侧（处置组）的估计图 p_mxh2 图 5.3: m(x)在断点断点右侧（处置组）的估计图 综合上面，得到CEF m(x)在断点两侧的估计图： p_mxh 图 5.4: m(x)在断点断点两侧的估计图 5.8.2 条件期望函数CEF m(x)的方差和标准差估计结果 直接使用谱宽a \\(h=8\\)进行局部线性LL估计，并利用留一法法计算得到预测误差 \\(\\tilde{\\boldsymbol{e}}\\)，并最终分别得断点两侧的协方差矩阵（见下式），从而进一步计算得到CEF估计值的方差和标准差（见后面附表）。 \\[\\begin{aligned} &amp;\\widehat{\\boldsymbol{V}}_{0}=\\left(\\sum_{i=1}^{n} K_{i} Z_{i} Z_{i}^{\\prime} \\cdot \\mathbb{1}\\left\\{X_{i}&lt;c\\right\\}\\right)^{-1}\\left(\\sum_{i=1}^{n} K_{i}^{2} Z_{i} Z_{i}^{\\prime} \\tilde{e}_{i}^{2} \\cdot \\mathbb{1}\\left\\{X_{i}&lt;c\\right\\}\\right)\\left(\\sum_{i=1}^{n} K_{i} Z_{i} Z_{i}^{\\prime} \\cdot \\mathbb{1}\\left\\{X_{i}&lt;c\\right\\}\\right)^{-1} \\\\ &amp;\\widehat{\\boldsymbol{V}}_{1}=\\left(\\sum_{i=1}^{n} K_{i} Z_{i} Z_{i}^{\\prime} \\cdot \\mathbb{1}\\left\\{X_{i} \\geq c\\right\\}\\right)^{-1}\\left(\\sum_{i=1}^{n} K_{i}^{2} Z_{i} Z_{i}^{\\prime} \\tilde{\\boldsymbol{e}}_{i}^{2} \\cdot \\mathbb{1}\\left\\{X_{i} \\geq c\\right\\}\\right)\\left(\\sum_{i=1}^{n} K_{i} Z_{i} Z_{i}^{\\prime} \\cdot \\mathbb{1}\\left\\{X_{i} \\geq c\\right\\}\\right)^{-1} \\end{aligned}\\] 这里我们没有再次评估条件方差估计中的最优谱宽，而是简单直接地使用了CEF估计时的谱宽。 但是我们还是要注意，二者的最优谱宽可以完全不相同！ 我们得到条件期望函数CEF m(x)的方差和标准差估计结果的计算附表如下： tb_mxh %&gt;% add_column(index = 1:nrow(.), .before = &quot;xg&quot;) %&gt;% select(index, group,xg,mx,s) %&gt;% mutate(s2 = s^2) %&gt;% DT::datatable(caption = &quot;m(x)的样本方差和标准差估计结果&quot;, options = list(dom =&quot;tip&quot;, pageLength =8, scrollX = TRUE)) %&gt;% formatRound(c(3), digits = c(1))%&gt;% formatRound(c(4:6), digits = c(4)) 5.8.3 条件期望函数CEF m(x)的置信区间和置信带 进一步计算局部线性估计下的逐点置信区间（Pointwise Conﬁdence Interval）（见后面附表），并得到置信带（见后面附图）。 \\[\\begin{align} \\widehat{m}(x) \\pm z_{1-\\alpha/2}(n-1) \\cdot \\sqrt{\\widehat{V}_{\\widehat{m}(x)}}\\\\ \\widehat{m}(x) \\pm 1.96 \\sqrt{\\widehat{V}_{\\widehat{m}(x)}} \\end{align}\\] 最终，条件期望函数CEF m(x)的置信区间和置信带结果计算表如下： tb_mxh %&gt;% add_column(index = 1:nrow(.), .before = &quot;xg&quot;) %&gt;% DT::datatable(caption = &quot;m(x)的逐点置信区间估计结果&quot;, options = list(dom =&quot;tip&quot;, pageLength =8, scrollX = TRUE)) %&gt;% formatRound(c(3), digits = c(1))%&gt;% formatRound(c(4:7), digits = c(4)) 断点左侧（控制组）的置信带图示如下： p_band_left 图 5.5: 断点左侧（控制组）的置信带 断点右侧（处置组）的置信带图示如下： p_band_right 图 5.6: 断点右侧（处置组）的置信带 综合起来，断点两侧的置信带图示如下： p_band 图 5.7: 断点两侧的置信带 5.8.4 RDD断点处置效应计算结果 根据断点处置效应定理，可以得到在断点 \\(x=c=59.1984\\)处对总体平均处置效应 \\(\\bar{\\theta}\\)的样本估计结果 \\(\\hat{\\theta}\\)： \\[\\begin{align} \\widehat{\\theta} &amp;=\\left[\\boldsymbol{\\widehat{\\beta}_{1}}(c)\\right]_{1}-\\left[\\boldsymbol{\\widehat{\\beta}_{0}}(c)\\right]_{1}\\\\ &amp;=\\hat{m}(c+)-\\widehat{m}(c-)\\\\ &amp;=3.3096 -1.8035 =-1.5060 \\end{align}\\] 断点处置效应估计值为 \\(\\hat{\\theta}=-1.5060\\)。 断点左边的条件期望(CEF)的估计值 \\(\\widehat{m}(c-)=3.31\\)； 断点右边的条件期望(CEF)的估计值 \\(\\widehat{m}(c+)=1.8\\)； 结论：援助项目的实施，减低了儿童死亡率，使得10万个孩子中约1.51个小孩免于遭受死亡。相比不实施项目援助，儿童死亡率由3.3096，下降到1.8035，降幅接近50%。 5.8.5 RDD断点处置效应的估计误差及显著性检验 进一步地，估计系数 \\(\\hat{\\theta}\\)的渐进方差为两个方差协方差矩阵第一个对角元素之和： \\[\\begin{align} \\text{Var}{(\\hat{\\theta})} &amp;=\\left[\\widehat{\\boldsymbol{V}}_{0}\\right]_{11}+\\left[\\widehat{\\boldsymbol{V}}_{1}\\right]_{11}\\\\ &amp;= 0.3673 + 0.1417 = 0.5090\\\\ se({(\\hat{\\theta})}) &amp;= \\sqrt{\\text{Var}{(\\hat{\\theta})}} = \\sqrt{0.5090} =0.7134 \\end{align}\\] .small[ &gt; - 断点左边的条件期望(CEF)的估计值 \\(\\widehat{m}(c-)=3.3096\\)； - 断点右边的条件期望(CEF)的估计值 \\(\\widehat{m}(c+)=1.8035\\)；] 结论：援助项目的实施，减低了儿童死亡率，使得10万个孩子中约-1.5060个小孩免于遭受死亡。相比不实施项目援助，儿童死亡率由3.3096，下降到1.8035，降幅接近50%。 5.9 过程6：等价线性回归 5.9.1 基本原理：调整运行变量范围 如前所述，骤变RDD断点处置效应也可以通过如下简单线性回归方法等价地得到 \\(\\widehat{\\theta}\\)的对应估计值： \\[\\begin{align} Y=\\beta_{0}+\\beta_{1} X+\\beta_{3}(X-c) D+\\theta D+e \\end{align}\\] 简单地，上述等价模型需要进行样本数据集的重新定义。具体地，运行变量 \\(X\\)的范围需要调整到 \\(X\\in [c-h^{\\ast}, c+h^{\\ast}]\\)，其中 \\(h^{\\ast}=\\sqrt{3}h=\\sqrt{3}\\times 8=13.86\\) 5.9.2 R运算代码 # set model mod_equiv &lt;- formula(&quot;Y~X +XcD +D&quot; ) # adjust bandwidth h_adj &lt;- h*sqrt(3) # new filtered data set dt_hd &lt;- dt_head %&gt;% filter((X&gt;=c-h_adj) &amp;(X&lt;=c+h_adj)) %&gt;% mutate(XcD=(X-c)*D) nhd &lt;- nrow(dt_hd) # descriptive statistics smry_new &lt;- dt_hd %&gt;% group_by(D) %&gt;% dplyr::summarize(n = n(), x_mean = mean(X, na.rm =T), x_min = min(X,na.rm = T), x_max = max(X, na.rm = T), x_sd = sd(X), y_mean = mean(Y, na.rm =T), y_min = min(Y,na.rm = T), y_max = max(Y, na.rm = T), y_sd = sd(Y) ) %&gt;% pivot_longer(names_to = &quot;stat&quot;, values_to = &quot;value&quot;, -D) %&gt;% pivot_wider(names_from = D, values_from = value) %&gt;% rename_all(., ~c(&quot;stats&quot;,&quot;D0&quot;,&quot;D1&quot;)) # t test tstat_new &lt;-2.10 pvalue_new &lt;- pt(tstat_new,df = nhd-4,lower.tail = FALSE) 5.9.3 过程步骤解读 5.9.3.1 等价线性回归：调整后的数据集 dt_hd %&gt;% add_column(obs = 1:nrow(.), .before = &quot;X&quot;) %&gt;% DT::datatable( caption = paste0(&quot;调整过后的数据集(n=&quot;,nrow(dt_hd),&quot;)&quot;), options = list(dom = &quot;tip&quot;, pageLength =8))%&gt;% formatRound(c(2,3,5), digits = 4) 样本数据的描述性统计如下： summary(dt_hd) X Y D Min. :45 Min. : 0 Min. :0.00 1st Qu.:50 1st Qu.: 0 1st Qu.:0.00 Median :55 Median : 0 Median :0.00 Mean :56 Mean : 3 Mean :0.34 3rd Qu.:62 3rd Qu.: 4 3rd Qu.:1.00 Max. :73 Max. :65 Max. :1.00 XcD Min. : 0.0 1st Qu.: 0.0 Median : 0.0 Mean : 1.8 3rd Qu.: 2.4 Max. :13.8 5.9.3.2 等价线性回归：分组描述性统计 smry_new %&gt;% DT::datatable( caption = paste0(&quot;处置组和控制组描述性统计(n=&quot;,nhd,&quot;)&quot;), options = list(dom = &quot;tip&quot;, pageLength =10, scrollX = TRUE))%&gt;% formatRound(c(2:3), digits = 2) 5.9.3.3 等价线性回归：OLS估计结果 lx_est &lt;- xmerit::lx.est(lm.mod = mod_equiv , lm.dt = dt_hd, lm.n = 5, opt = c(&quot;s&quot;,&quot;t&quot;), inf = c(&quot;over&quot;,&quot;fit&quot;,&quot;Ftest&quot;), digits = c(4,4,2,4)) \\[\\begin{equation} \\begin{alignedat}{999} &amp;\\widehat{Y}=&amp;&amp;-1.0987&amp;&amp;+0.0758X_i&amp;&amp;+0.0331XcD_i&amp;&amp;-1.5454D_i\\\\ &amp;(s)&amp;&amp;(2.9382)&amp;&amp;(0.0564)&amp;&amp;(0.1060)&amp;&amp;(0.7375)\\\\ &amp;(t)&amp;&amp;(-0.37)&amp;&amp;(+1.34)&amp;&amp;(+0.31)&amp;&amp;(-2.10)\\\\ &amp;(over)&amp;&amp;n=757&amp;&amp;\\hat{\\sigma}=5.1830 &amp;&amp; &amp;&amp;\\\\ &amp;(fit)&amp;&amp;R^2=0.0059&amp;&amp;\\bar{R}^2=0.0019 &amp;&amp; &amp;&amp;\\\\ &amp;(Ftest)&amp;&amp;F^*=1.48&amp;&amp;p=0.2191 &amp;&amp; &amp;&amp; \\end{alignedat} \\end{equation}\\] 用上述等价回归法估计得到的断点处置效应估计值为 \\(\\widehat{\\theta}=-1.5454\\)，样本t统计量为 \\(t^{\\ast}=-2.10\\)，对应的概率值为 \\(p=0.0180\\)，表明是统计显著的。 参考文献 "],["lab-srdd-withcovs.html", "Lab 6 引入协变量的RDD效应分析（儿童死亡率案例） 6.1 实验说明 6.2 案例描述 6.3 过程0：设定相关参数和辅助计算工具 6.4 过程2：协变量SRDD估计 6.5 过程3：将RDD估计结果整理成相关表格 6.6 过程4：绘制RDD分析图（mx估计值） 6.7 过程5：绘制RDD置信带图 6.8 协变量RDD分析的过程步骤解读 6.9 过程6：无协变量SRDD和有协变量SRDD的比较 参考文献", " Lab 6 引入协变量的RDD效应分析（儿童死亡率案例） 6.1 实验说明 6.1.1 实验内容 实验目标：引入协变量情况下，骤变RDD的局部线性回归估计及分析，复现儿童死亡率案例（包括Table21.1、Figure 21.2a的全部过程及结果（参看：HANSEN B. Econometrics[M].2021（作者手稿）. 第21章 Regression Discontinuity. ） 主要内容包括： 在引入两个额外协变量情形下，基于骤变RDD（SRDD）模型，进行局部线性回归方法（LLR）分析，估计其断点处置效应ATE（\\(\\widehat{\\theta}\\)）及其估计标准误。 对比无协变量SRDD模型（上一次实验）和有协变量SRDD，对这两个模型进行综合比较，并得出相关结论 6.1.2 材料准备 软件环境：编译器为Rstudio（要求R 4.1及以上版本） R代码文件：工作项目（R project）根目录下Rscript/文件夹内 # don&#39;t run here ! # only show you the code file path! source(&quot;../Rscript/hansen21-fig21-2a.R&quot;, encoding = &quot;UTF-8&quot;) 注意：上述代码运行时间较长（约3-5分钟），为提高渲染效率代码文件仅需运行一次。 6.2 案例描述 6.2.1 死亡率案例（续）：背景说明 援助项目与儿童死亡率： 我们继续使用前面(Ludwig J 等, 2007)的研究案例，来评估美国联邦政府脱贫援助项目（Head Start）对儿童死亡率的骤变RDD政策效应。现在我们考虑使用两个协变量（covariates）： 县级黑人人口占比（black pop percentage） \\(Z_a\\) 县级城镇人口占比（urban pop percentage） \\(Z_a\\) ] 上述两个协变量，本质上可以视作为收入变量（income）的代理变量（proxy）。 下面我们将使用(Robinson P M, 1988)的半参数效率估计方法来评估项目援助的断点处置效应（RDD ATE）。 6.2.2 读取案例数据 ## This file generates Figure 21.2a and Table 21.1 Covariates ## Head Start RDD with Covariates ## This file uses the package haven ## This file uses the data file LM2007.dta #### The data file LM2007.dta is used #### library(haven) dt_path &lt;- here::here(&quot;data/LM2007.dta&quot;) dat &lt;- read_dta(dt_path) y &lt;- dat$mort_age59_related_postHS x &lt;- dat$povrate60 Za &lt;- dat$census1960_pctblack Zb &lt;- dat$census1960_pcturban c &lt;- 59.1984 dt_head &lt;- tibble(X= x, Y = y, Za = Za, Zb = Zb) %&gt;% mutate(D= ifelse(X&gt;=c,1,0)) 6.2.3 数据呈现 dt_head %&gt;% add_column(obs = 1:nrow(.), .before = &quot;X&quot;) %&gt;% DT::datatable( caption = paste0(&quot;增加协变量的援助项目数据集(n=2783)&quot;), options = list(dom = &quot;tip&quot;, pageLength =8))%&gt;% formatRound(c(2:5), digits = c(4,4,1,1)) 样本数据的描述性统计如下： summary(dt_head) X Y Za Zb Min. :15 Min. : 0 Min. : 0 Min. : 0 1st Qu.:24 1st Qu.: 0 1st Qu.: 0 1st Qu.: 0 Median :34 Median : 0 Median : 2 Median : 28 Mean :37 Mean : 2 Mean :11 Mean : 29 3rd Qu.:47 3rd Qu.: 3 3rd Qu.:15 3rd Qu.: 48 Max. :82 Max. :136 Max. :83 Max. :100 D Min. :0.00 1st Qu.:0.00 Median :0.00 Mean :0.11 3rd Qu.:0.00 Max. :1.00 6.2.4 数据分组描述性统计 我们根据处置变量D进行数据分组，并进行描述性统计，统计分析代码如下： smry_grouped &lt;- dt_head %&gt;% group_by(D) %&gt;% dplyr::summarize(n = n(), x_mean = mean(X, na.rm =T), x_min = min(X,na.rm = T), x_max = max(X, na.rm = T), x_sd = sd(X), y_mean = mean(Y, na.rm =T), y_min = min(Y,na.rm = T), y_max = max(Y, na.rm = T), y_sd = sd(Y), za_mean = mean(Za, na.rm =T), za_min = min(Za,na.rm = T), za_max = max(Za, na.rm = T), za_sd = sd(Za), zb_mean = mean(Zb, na.rm =T), zb_min = min(Zb,na.rm = T), zb_max = max(Zb, na.rm = T), zb_sd = sd(Zb) ) %&gt;% pivot_longer(names_to = &quot;stat&quot;, values_to = &quot;value&quot;, -D) %&gt;% pivot_wider(names_from = D, values_from = value) %&gt;% rename_all(., ~c(&quot;stats&quot;,&quot;D0&quot;,&quot;D1&quot;)) 处置组和控制组描述性统计表如下： smry_grouped %&gt;% arrange(desc(stats)) %&gt;% DT::datatable( caption = paste0(&quot;处置组和控制组描述性统计(g=&quot;,n,&quot;)&quot;), options = list(dom = &quot;tip&quot;, pageLength =10, scrollX = TRUE))%&gt;% formatRound(c(2:3), digits = 2) 6.2.5 数据散点图 #### basic plot #### lwd &lt;- 0.6 fsize &lt;- 16 p0 &lt;- ggplot() + geom_point(aes(X, Y),data = dt_head, pch=21,alpha=0.6) + geom_vline(aes(xintercept=c), color = &quot;orange&quot;, lty = &quot;dotted&quot;, lwd=lwd) + labs(x= &quot;X贫困线&quot;, y =&quot;Y儿童死亡率&quot;) + scale_y_continuous(breaks = seq(0,80,20), limits = c(0,80)) + scale_x_continuous(breaks = seq(10,90,10), limits = c(10,90)) + theme_bw() + theme(text = element_text(size = fsize)) # show the scatter p0 图 6.1: 样本数据散点图n=r n 6.3 过程0：设定相关参数和辅助计算工具 6.3.1 R运算代码 考虑到对断点两侧的数据，我们要多次进行局部线性估计（LLR）、计算预测误差、计算标准误（从而计算置信区间），因此我们可以事先设计并封装好一些有用的辅助函数（辅助工具）。 为了简化计算，我们这里不再进行LLR的最优谱宽选择过程，而是直接先验设定好一个初始值（\\(h=8\\)）。 我们会多次分别对断点两侧运用LLR估计流程（我们已经在非参数局部回归估计中学习过了！） #### RDD Helper function #### # specify parameters and basic calculation h &lt;- 8 T &lt;- as.numeric(x &gt;= c) y1 &lt;- y[T==0] y2 &lt;- y[T==1] x1 &lt;- x[T==0] x2 &lt;- x[T==1] n1 &lt;- length(y1) n2 &lt;- length(y2) n &lt;- n1+n2 # specify bins g1 &lt;- seq(15,59.2,.2) g2 &lt;- seq(59.2,82,.2) G1 &lt;- length(g1) G2 &lt;- length(g2) # Helper function for triangle kernel function TriKernel &lt;- function(x) { s6 &lt;- sqrt(6) ax &lt;- abs(x) f &lt;- (1-ax/s6)*(ax &lt; s6)/s6 return(f) } # Helper function for LLR estimation LL_EST &lt;- function(y,x,g,h) { G &lt;- length(g) m &lt;- matrix(0,G,1) z &lt;- matrix(1,length(y),1) for (j in 1:G){ xj &lt;- x-g[j] K &lt;- TriKernel(xj/h) zj &lt;- cbind(z,xj) zz &lt;- t(cbind(K,xj*K)) beta &lt;- solve(zz%*%zj,zz%*%y) m[j] &lt;- beta[1] } return(m) } # Helper function for forecast residuals LL_Residual &lt;- function(y,x,h) { n &lt;- length(y) e &lt;- matrix(0,n,1) z &lt;- matrix(1,n,1) for (j in 1:n){ xj &lt;- x-x[j] K &lt;- TriKernel(xj/h) K[j] &lt;- 0 zj &lt;- cbind(z,xj) zz &lt;- t(cbind(K,xj*K)) beta &lt;- solve(zz%*%zj,zz%*%y) e[j] &lt;- y[j] - beta[1] } return(e) } # Helper function for standard error LL_SE &lt;- function(y,x,g,h) { G &lt;- length(g) s &lt;- matrix(0,G,1) z &lt;- matrix(1,length(y),1) e &lt;- LL_Residual(y,x,h) for (j in 1:G){ xj &lt;- x-g[j] K &lt;- TriKernel(xj/h) zj &lt;- cbind(z,xj) zz &lt;- cbind(K,xj*K) ZKZ &lt;- solve(t(zz)%*%zj) Ke &lt;- K*e ze &lt;- cbind(Ke,xj*Ke) V &lt;- ZKZ%*%crossprod(ze)%*%ZKZ s[j] = sqrt(V[1,1]) } return(s) } 6.3.2 过程步骤解读：协变量RDD分析的规则策略 在进行协变量RDD分析之前，我们设定如下的规则策略： 规则1：我们设定先验谱宽为 \\(h=8\\)，断点值设定为 \\(c =59.1984\\%\\)。 规则2：分别设定断点两边箱组中心点序列值（center of bins）。我们将采用非对称箱组设置方法： 控制组（断点左边）的评估范围为 \\([15, 59.2]\\)，序列间隔为0.2。评估总箱组数为 \\(g1=222\\)，待评估序列值为 \\(15.0, 15.2, 15.4, 15.6, 15.8, \\cdots,58.6, 58.8, 59.0, 59.2\\)。 处置组（断点右边）的评估范围为 \\([59.2, 82]\\)，序列间隔为0.2。评估总箱组数为 \\(g2=115\\)，待评估序列值为 \\(59.2, 59.4, 59.6, 59.8, 60.0, \\cdots,81.4, 81.6, 81.8, 82.0\\)。 规则3：如果使用局部线性估计法（LL），则采用三角核函数（triangle kenerl）。 规则4：我们将使用(Robinson P M, 1988)的半参数效率估计方法来评估断点处置效应（RDD ATE）。 6.4 过程2：协变量SRDD估计 协变量SRDD过程（R代码）如下： #### RDD Estimation #### #### step 1: LL estimate Y on X #### ## obtain residual of stage 1 e1 &lt;- LL_Residual(y1,x1,h) e2 &lt;- LL_Residual(y2,x2,h) e &lt;- rbind(e1,e2) #### step 2: LL estimate Z on X #### ## obtain residual of stage 2 Ra &lt;- LL_Residual(Za,x,h) Rb &lt;- LL_Residual(Zb,x,h) Z &lt;- cbind(Za,Zb) R &lt;- cbind(Ra,Rb) # step 3: OLS #### ## regress estimate residual of stage 1 on residual of stage 2 ## obtain the coefﬁcient and standard errors ## no intercept ! XXR &lt;- solve(crossprod(R)) # inverse matrix beta &lt;- XXR%*%(t(R)%*%e) u &lt;- e - R%*%beta Ru &lt;- R*(u%*%matrix(1,1,ncol(R))) V &lt;- XXR%*%crossprod(Ru)%*%XXR # robust se sbeta &lt;- sqrt(diag(V)) tstat &lt;- beta/sbeta pvalue &lt;- 2*(1-pnorm(abs(tstat))) betas &lt;- cbind(beta,sbeta,tstat,pvalue) #### step 4: Construct the residual #### ## obtain constructed residual zm &lt;- colMeans(Z)%*%beta Z1 &lt;- Z[T==0,] Z2 &lt;- Z[T==1,] yZ &lt;- y - Z%*%beta yZ1 &lt;- y1 - Z1%*%beta yZ2 &lt;- y2 - Z2%*%beta #### step 5: LL ATE estimate #### ## LL estimate of constructed residual on X ## obtain ATE and standard errors m1 &lt;- LL_EST(yZ1,x1,g1,h) + matrix(zm,G1,1) m2 &lt;- LL_EST(yZ2,x2,g2,h) + matrix(zm,G2,1) s1 &lt;- LL_SE(yZ1,x1,g1,h) s2 &lt;- LL_SE(yZ2,x2,g2,h) L1 &lt;- m1-1.96*s1 U1 &lt;- m1+1.96*s1 L2 &lt;- m2-1.96*s2 U2 &lt;- m2+1.96*s2 # rdd effect theta_lft &lt;- m1[G1] theta_rgt &lt;- m2[1] theta &lt;- m2[1]-m1[G1] setheta &lt;- sqrt(s1[G1]^2 + s2[1]^2) tstat &lt;- theta/setheta pvalue &lt;- 2*(1-pnorm(abs(tstat))) 6.5 过程3：将RDD估计结果整理成相关表格 6.5.1 将断点两侧的m(x)估计结果整理成表格（R代码） #### tibble of mx estimate related #### tbl_mx1 &lt;- tibble(group = &quot;control&quot;, xg = g1, mx=as.vector(m1), s = as.vector(s1), lwr = as.vector(L1), upr = as.vector(U1)) tbl_mx2 &lt;- tibble(group = &quot;treat&quot;, xg = g2, mx=as.vector(m2), s = as.vector(s2), lwr = as.vector(L2), upr = as.vector(U2)) tb_mxh &lt;- bind_rows(tbl_mx1, tbl_mx2) 6.5.2 将RDD预测误差整理成表格（R代码） #### tibble of sample result #### tbl_residual &lt;- dt_head %&gt;% mutate(e = as.vector(e), # residual of LL 1 Ra = as.vector(Ra), # residual of LL 2 Rb = as.vector(Rb), RZ = as.vector(yZ) # residual of construct ) 6.5.3 将最终RDD断点效应整理成表格（R代码） #### tibble of estimate result #### tbl_theta02 &lt;- tibble( model = &quot;covariate&quot;, pars = c(&quot;theta&quot;, &quot;black&quot;,&quot;urban&quot;), est = c(theta, as.vector(beta)), se = c(setheta, as.vector(sbeta)) ) 6.6 过程4：绘制RDD分析图（mx估计值） 6.6.1 对绘制底图（R代码） lwd &lt;- 0.6 lwadd &lt;- 0.2 p00 &lt;- ggplot() + geom_point(aes(X, Y),data = dt_head, pch=21,alpha=0.3) + geom_vline(aes(xintercept=c), color = &quot;red&quot;, lty = &quot;dotted&quot;, lwd=lwd) + labs(x= &quot;X贫困线&quot;, y =&quot;Y儿童死亡率&quot;) + scale_y_continuous(breaks = seq(0,5,1), limits = c(0,5)) + scale_x_continuous(breaks = seq(10,85,10), limits = c(10,85)) + theme_bw() + theme(text = element_text(size = fsize)) 6.6.2 对断点左边绘制mx估计图（R代码） # mx plot for left part p_mxh1 &lt;- p00 + geom_line(aes(x = xg, y = mx, color=&quot;m1&quot;, lty=&quot;m1&quot;), lwd = lwd+lwadd, data = base::subset(tb_mxh,group==&quot;control&quot;)) + scale_color_manual( name=&quot;&quot;, breaks = c(&quot;m1&quot;), labels = c(expression(m(x):control)), values=c(&quot;purple&quot;))+ scale_linetype_manual( name=&quot;&quot;, breaks = c(&quot;m1&quot;), labels = c(expression(m(x):control)), values=c(&quot;solid&quot;))+ theme(legend.position = &quot;right&quot;, text = element_text(size = fsize)) 6.6.3 对断点右边绘制mx估计图（R代码） # mx plot for right part p_mxh2 &lt;- p00 + geom_line(aes(x = xg, y = mx, color=&quot;m2&quot;, lty=&quot;m2&quot;), lwd = lwd+lwadd, data = base::subset(tb_mxh,group==&quot;treat&quot;)) + scale_color_manual( name=&quot;&quot;, breaks = c(&quot;m2&quot;), labels = c(expression(m(x):treat)), values=c(&quot;blue&quot;))+ scale_linetype_manual( name=&quot;&quot;, breaks = c(&quot;m2&quot;), labels = c(expression(m(x):treat)), values=c(&quot;solid&quot;))+ theme(legend.position = &quot;right&quot;, text = element_text(size = fsize)) 6.6.4 同时对断点两边绘制mx估计图（R代码） # mx plot for both side p_mxh &lt;- p00 + geom_line(aes(x = xg, y = mx, color=&quot;m1&quot;, lty=&quot;m1&quot;), lwd = lwd+lwadd, data = base::subset(tb_mxh,group==&quot;control&quot;)) + geom_line(aes(x = xg, y = mx, color=&quot;m2&quot;, lty=&quot;m2&quot;), lwd = lwd+lwadd, data = base::subset(tb_mxh,group==&quot;treat&quot;)) + scale_color_manual( name=&quot;&quot;, breaks = c(&quot;m1&quot;, &quot;m2&quot;), labels = c(expression(m(x):control),expression(m(x):treat)), values=c(&quot;purple&quot;, &quot;blue&quot;))+ scale_linetype_manual( name=&quot;&quot;, breaks = c(&quot;m1&quot;, &quot;m2&quot;), labels = c(expression(m(x):control),expression(m(x):treat)), values=c(&quot;solid&quot;, &quot;solid&quot;))+ theme(legend.position = &quot;right&quot;, text = element_text(size = fsize)) 6.7 过程5：绘制RDD置信带图 6.7.1 对断点左边绘制置信带（R代码） #### Plot Confidence Bands #### # band plot for left side p_band_left &lt;- p_mxh1 + geom_ribbon(aes(x=xg,ymin = lwr, ymax = upr), data = base::subset(tb_mxh,group==&quot;control&quot;), alpha = 0.2) 6.7.2 对断点右边绘制置信带（R代码） # band plot for right side p_band_right &lt;- p_mxh2 + geom_ribbon(aes(x=xg,ymin = lwr, ymax = upr), data = base::subset(tb_mxh,group==&quot;treat&quot;), alpha = 0.2) 6.7.3 对断点两边同时绘制置信带（R代码） # band plot for right side # band plot for both side p_band_cov &lt;- p_mxh + geom_ribbon(aes(x=xg,ymin = lwr, ymax = upr), data = base::subset(tb_mxh,group==&quot;control&quot;), alpha = 0.2) + geom_ribbon(aes(x=xg,ymin = lwr, ymax = upr), data = base::subset(tb_mxh,group==&quot;treat&quot;), alpha = 0.2) + geom_text(aes(x = c-3, y = theta_lft, label=number(theta_lft, 0.0001)), color = &quot;purple&quot;)+ geom_text(aes(x = c+3, y = theta_rgt, label=number(theta_rgt, 0.0001)), color = &quot;blue&quot;) + geom_segment(aes(x=c, xend = c, y= theta_lft, yend = theta_rgt), arrow = arrow(length = unit(0.1,&quot;cm&quot;), type = &quot;closed&quot;), lty = &quot;solid&quot;, color= &quot;orange&quot;, lwd=lwd) + geom_text(aes(x = c+5, y=theta_lft+0.5*theta), label = TeX(paste0(&quot;\\\\hat{\\\\theta}=&quot;,number(theta,0.0001))), color= &quot;orange&quot;, size=4) 6.8 协变量RDD分析的过程步骤解读 6.8.1 第1阶段LLR估计残差 步骤1：直接采用前面的局部线性回归方法（LLR），用 \\(Y_i\\)对 \\(X_i\\)进行LL回归，得到第1阶段的结果变量的拟合值 \\(\\widehat{m}_i = \\widehat{m}_i(X_i)\\)，并进一步构造留一法残差a \\(Y_i - \\widehat{m}_i\\) tbl_residual %&gt;% add_column(obs = 1:nrow(.), .before = &quot;X&quot;) %&gt;% select(obs,D,X,Y,Za,Zb,e) %&gt;% DT::datatable( caption = paste0(&quot;RDD LL估计得到的残差(n=&quot;,n,&quot;)&quot;), options = list(dom = &quot;tip&quot;, pageLength =6))%&gt;% formatRound(c(3:7), digits = c(4,4,1,1,4)) a 这个阶段的残差序列用e命名。 6.8.2 第2阶段LLR估计残差 步骤2：同上，依次做 \\(Z_a\\)对 \\(X_i\\)、 \\(Z_b\\)对 \\(X_i\\)的局部线性回归（LLR），并分别得到协变量的拟合值 \\(\\widehat{g}_{1i},\\widehat{g}_{2i}\\)，及其对应残差a \\((Z_a-\\widehat{g}_{1i}),(Z_b-\\widehat{g}_{2i})\\) tbl_residual %&gt;% add_column(obs = 1:nrow(.), .before = &quot;X&quot;) %&gt;% select(obs,D,X,Y,Za,Zb,e,Ra,Rb) %&gt;% DT::datatable( caption = paste0(&quot;RDD LL估计得到的残差(n=&quot;,n,&quot;)&quot;), options = list(dom = &quot;tip&quot;, pageLength =6))%&gt;% formatRound(c(3:9), digits = c(4,4,1,1,4,4,4)) a 这个阶段的两个残差序列分别用Ra和Rb命名。 6.8.3 第3阶段OLS估计(模型) 步骤3：利用前面两个阶段的残差，做 \\(Y_i -m_{i}\\)对 \\(Z_{i1}-\\widehat{g}_{1i},Z_{i2}-\\widehat{g}_{2i},\\ldots,Z_{ik}-\\widehat{g}_{ki}\\)的无截距的普通最小二乘回归（OLS），并得到估计系数 \\(\\hat{\\beta}\\)及其标准误 \\[\\begin{align} (Y_i -m_{i}) &amp;= \\hat{\\beta}_1(Z_{ia}-\\widehat{g}_{1i})+\\hat{\\beta}_2(Z_{ib}-\\widehat{g}_{2i})\\\\ e&amp;=\\hat{\\beta}_{1}R_a + \\hat{\\beta}_{2}R_a \\end{align}\\] 6.8.4 第3阶段OLS估计（结果） 上述模型，未矫正标准误下OLS估计的结果如下a ： mod_res &lt;- formula(e~-1+Ra+Rb) lx_est &lt;- xmerit::lx.est(lm.mod = mod_res , lm.dt = tbl_residual, lm.n = 5, opt = c(&quot;s&quot;,&quot;t&quot;,&quot;p&quot;), inf = c(&quot;over&quot;), digits = c(4,4,2,4)) \\[\\begin{equation} \\begin{alignedat}{999} &amp;\\widehat{e}=&amp;&amp;+0.0265Ra_i&amp;&amp;-0.0094Rb_i\\\\ &amp;(s)&amp;&amp;(0.0083)&amp;&amp;(0.0045)\\\\ &amp;(t)&amp;&amp;(+3.19)&amp;&amp;(-2.08)\\\\ &amp;(p)&amp;&amp;(0.0014)&amp;&amp;(0.0377)\\\\ &amp;(over)&amp;&amp;n=2783&amp;&amp;\\hat{\\sigma}=5.7091 \\end{alignedat} \\end{equation}\\] 上述模型，进行稳健标准误矫正OLS估计的结果如下b ： library(robustbase) library(sandwich) library(lmtest) library(modelr) library(broom) # regression with robust standard errors using R ## see [url](https://www.brodrigues.co/blog/2018-07-08-rob_stderr/) lm.out &lt;- lm(formula = mod_res, data =tbl_residual ) broom::tidy( lmtest::coeftest(lm.out, vcov = sandwich::vcovHC(lm.out)) ) %&gt;% DT::datatable( caption = paste0(&quot;稳健标准误OLS估计(n=&quot;,n,&quot;)&quot;), options = list(dom = &quot;t&quot;, pageLength =6))%&gt;% formatRound(c(2:5), digits = c(4,4,2,4)) a b 两种OLS估计程序下，回归系数都相同，只是系数对应的标准误不一样。这里我们仅需要用到回归系数，因此不影响后续步骤。 6.8.5 第4阶段构造残差 步骤4：利用前面的OLS估计系数，我们就可以构造得到残差 \\(\\hat{e}_i=Y_i - Z^{\\prime}_i\\hat{\\beta}\\) tbl_residual %&gt;% add_column(obs = 1:nrow(.), .before = &quot;X&quot;) %&gt;% select(obs,D,X,Y,Za,Zb,e,Ra,Rb,RZ) %&gt;% DT::datatable( caption = paste0(&quot;RDD LL估计得到的残差(n=&quot;,n,&quot;)&quot;), options = list(dom = &quot;tip&quot;, pageLength =6))%&gt;% formatRound(c(3:10), digits = c(4,4,1,1,4,4,4,4)) a 这个步骤构造出来的残差序列RZ。 6.8.6 条件期望函数CEF m(x)的LLR估计结果 步骤5：再次采用RDD局部线性回归方法（LLR），进行 \\(\\hat{e}_i\\)对 \\(X_i\\)的回归，并计算得到非参数估计量 \\(\\widehat{m}(x)\\)，断点效应估计值 \\(\\hat{\\theta}\\)及其标准误。 tb_mxh %&gt;% add_column(index = 1:nrow(.), .before = &quot;xg&quot;) %&gt;% select(index,group, xg,mx) %&gt;% DT::datatable(caption = &quot;局部线性估计LL方法对m(x)的估计结果&quot;, options = list(dom =&quot;tip&quot;, pageLength =6, scrollX = TRUE)) %&gt;% formatRound(c(3), digits = c(1))%&gt;% formatRound(c(4), digits = c(4)) 基于此，我们可以分别得到CEF m(x)在断点左侧（控制组）的估计图 p_mxh1 图 6.2: m(x)在断点左侧（控制组）的估计图 类似地，也可以得到CEF m(x)在断点右侧（处置组）的估计图 p_mxh2 图 6.3: m(x)在断点断点右侧（处置组）的估计图 综合上面，得到CEF m(x)在断点两侧的估计图： p_mxh 图 6.4: m(x)在断点断点两侧的估计图 6.8.7 条件期望函数CEF m(x)的标准差和置信区间 同前，进一步计算得到CEF估计值的方差和标准差以及95%置信区间 tb_mxh %&gt;% add_column(index = 1:nrow(.), .before = &quot;xg&quot;) %&gt;% select(index, group,xg,mx,s,lwr,upr) %&gt;% #mutate(s2 = s^2) %&gt;% DT::datatable(caption = &quot;m(x)的样本方差和标准差估计结果&quot;, options = list(dom =&quot;tip&quot;, pageLength =8, scrollX = TRUE)) %&gt;% formatRound(c(3), digits = c(1))%&gt;% formatRound(c(4:7), digits = c(4)) 断点左侧（控制组）的置信带图示如下： p_band_left 图 6.5: 断点左侧（控制组）的置信带 断点右侧（处置组）的置信带图示如下： p_band_right 图 6.6: 断点右侧（处置组）的置信带 综合起来，断点两侧的置信带图示如下： p_band_cov 图 6.7: 断点两侧的置信带 6.8.8 RDD断点处置效应计算结果 根据断点处置效应定理，可以得到在断点 \\(x=c=59.1984\\)处对总体平均处置效应 \\(\\bar{\\theta}\\)的样本估计结果 \\(\\hat{\\theta}\\)： \\[\\begin{align} \\widehat{\\theta} &amp;=\\left[\\boldsymbol{\\widehat{\\beta}_{1}}(c)\\right]_{1}-\\left[\\boldsymbol{\\widehat{\\beta}_{0}}(c)\\right]_{1}\\\\ &amp;=\\hat{m}(c+)-\\widehat{m}(c-)\\\\ &amp;= 2.8209 - 1.2592 = -1.5617 \\end{align}\\] 断点处置效应估计值为 \\(\\hat{\\theta}=-1.5617\\)。 断点左边的条件期望(CEF)的估计值 \\(\\widehat{m}(c-)=2.8209\\)； 断点右边的条件期望(CEF)的估计值 \\(\\widehat{m}(c+)=1.2592\\)； 结论：援助项目的实施，减低了儿童死亡率，使得10万个孩子中约-1.5617个小孩免于遭受死亡。相比不实施项目援助，儿童死亡率由2.8209，下降到1.2592，降幅接近50%。 6.8.9 RDD断点处置效应的估计误差及显著性检验 进一步地，估计系数 \\(\\hat{\\theta}\\)的渐进方差为两个方差协方差矩阵第一个对角元素之和： \\[\\begin{align} \\text{Var}{(\\hat{\\theta})} &amp;=\\left[\\widehat{\\boldsymbol{V}}_{0}\\right]_{11}+\\left[\\widehat{\\boldsymbol{V}}_{1}\\right]_{11}\\\\ &amp;= 0.3673 + 0.1417 = 0.5090\\\\ se({(\\hat{\\theta})}) &amp;= \\sqrt{\\text{Var}{(\\hat{\\theta})}} = \\sqrt{0.5090} =0.7122 \\end{align}\\] 因此RDD断点处置效应估计值 \\(\\hat{\\theta}\\)的标准误为 \\(se({\\hat{\\theta}}) =0.7122\\)；最后我们可以计算得到RDD断点处置效应对应的t统计量： \\(t^{\\ast}=\\frac{\\hat{\\theta}}{se(\\hat{\\theta})}=-2.19\\)，其概率值为 \\(p=0.0283\\). 综上，RDD结果表明援助项目降低了儿童死亡率，使得10万个孩子中约1.56个小孩免于遭受死亡。并且t统计量检验表明，援助项目在降低了儿童死亡率上具有统计显著性（置信度超过95%）。 6.9 过程6：无协变量SRDD和有协变量SRDD的比较 6.9.1 R运算代码 比较Hansen Head Start案例基准RDD和协变量RDd tbl_theta &lt;- bind_rows( tbl_theta01, # baseline RDD tbl_theta02 # coviriate RDD ) %&gt;% pivot_longer(names_to = &quot;stats&quot;, values_to = &quot;value&quot;, est:se) %&gt;% pivot_wider(names_from = &quot;model&quot;, values_from =&quot;value&quot; ) 6.9.2 过程步骤解读1：系数和标准误比较 tbl_theta %&gt;% DT::datatable( caption = paste0(&quot;基准RDD和协变量RDD估计结果对比&quot;), options = list(dom = &quot;t&quot;, pageLength =6))%&gt;% formatRound(c(3:4), digits = c(4)) 结论1：与基准RDD相比，两个协变量的引入没有明显改变断点处置效应估计值大小。 结论2：但是是否引入协变量，对CEF估计值 \\(\\widehat{m}(x)\\)的影响较大。可以看到基准RDD更陡峭，而协变量RDD更平缓。（见后面附图对比） 结论3：考虑到两个协变量可以视作收入的代理变量，可以看到黑人人口比重负向影响儿童死亡率，而城镇人口比重正向影响儿童死亡率。 6.9.3 过程步骤解读2：CEF估计值图形比较 p_band_wrapper 图 6.8: 基准RDD：局部线性回归及断点效应估计 p_band_cov 图 6.9: 协变量RDD：局部线性回归及断点效应估计 参考文献 "],["appendix.html", "Lab 7 附录 7.1 常用stata命令", " Lab 7 附录 7.1 常用stata命令 参看在线pdf 7.1.1 数列操作 命令1(2)9，得到：1, 3, 5, 7, 9 命令1/9，得到：1, 2, 3, 4, 5, 6, 7, 8, 9 7.1.2 时期操作 （1）滞后操作： L.表示滞后一期，例如L.x表示\\(x_{t-1}\\) L2.表示滞后2期，例如L2.x表示\\(x_{t-2}\\) （2）超前操作： F.表示滞后一期，例如F.x表示\\(x_{t+1}\\) F2.表示滞后2期，例如F2.x表示\\(x_{t+2}\\) （3）差分操作：D.或者D2.之类 （4）季节差分操作：S.或者S2.之类 7.1.3 条件下回归 命令regress var1 var2 if inrange(year,94,96)，表示仅使用部分数据（给定年份范围条件下）进行回归。 "]]
